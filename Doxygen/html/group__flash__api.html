<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vitalsgrafr UY: Flash_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vitalsgrafr UY
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Flash_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2368f7196b3e9312a0efe27074053559"><td class="memItemLeft" align="right" valign="top"><a id="ga2368f7196b3e9312a0efe27074053559"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_BURST_PRG_BIT</b>&#160;&#160;&#160;0x03</td></tr>
<tr class="separator:ga2368f7196b3e9312a0efe27074053559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30e9b97de2869f15e31d3c2a0374118"><td class="memItemLeft" align="right" valign="top"><a id="gad30e9b97de2869f15e31d3c2a0374118"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_PROGRAM_ERROR</b>&#160;&#160;&#160;FLCTL_IFG_PRG_ERR</td></tr>
<tr class="separator:gad30e9b97de2869f15e31d3c2a0374118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga247b0ffff3d3ddf56a803d7b1aa0c2cd"><td class="memItemLeft" align="right" valign="top"><a id="ga247b0ffff3d3ddf56a803d7b1aa0c2cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_BENCHMARK_INT</b>&#160;&#160;&#160;FLCTL_IFG_BMRK</td></tr>
<tr class="separator:ga247b0ffff3d3ddf56a803d7b1aa0c2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga610f1476a13c1912e0e0caf89af27fad"><td class="memItemLeft" align="right" valign="top"><a id="ga610f1476a13c1912e0e0caf89af27fad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_ERASE_COMPLETE</b>&#160;&#160;&#160;FLCTL_IFG_ERASE</td></tr>
<tr class="separator:ga610f1476a13c1912e0e0caf89af27fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190ae9cac15634fb5ee60411b03c8d0c"><td class="memItemLeft" align="right" valign="top"><a id="ga190ae9cac15634fb5ee60411b03c8d0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_BRSTPRGM_COMPLETE</b>&#160;&#160;&#160;FLCTL_IFG_PRGB</td></tr>
<tr class="separator:ga190ae9cac15634fb5ee60411b03c8d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7606343714f3d35240469efcda4ec14"><td class="memItemLeft" align="right" valign="top"><a id="gab7606343714f3d35240469efcda4ec14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_WRDPRGM_COMPLETE</b>&#160;&#160;&#160;FLCTL_IFG_PRG</td></tr>
<tr class="separator:gab7606343714f3d35240469efcda4ec14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c84f65859f7f00f5096ec30ffef6529"><td class="memItemLeft" align="right" valign="top"><a id="ga6c84f65859f7f00f5096ec30ffef6529"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_POSTVERIFY_FAILED</b>&#160;&#160;&#160;FLCTL_IFG_AVPST</td></tr>
<tr class="separator:ga6c84f65859f7f00f5096ec30ffef6529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254433f9b70ca63823379fb9f339c504"><td class="memItemLeft" align="right" valign="top"><a id="ga254433f9b70ca63823379fb9f339c504"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_PREVERIFY_FAILED</b>&#160;&#160;&#160;FLCTL_IFG_AVPRE</td></tr>
<tr class="separator:ga254433f9b70ca63823379fb9f339c504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca4a02d4d21316b1c5dd37271b5bf34"><td class="memItemLeft" align="right" valign="top"><a id="ga1ca4a02d4d21316b1c5dd37271b5bf34"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_BRSTRDCMP_COMPLETE</b>&#160;&#160;&#160;FLCTL_IFG_RDBRST</td></tr>
<tr class="separator:ga1ca4a02d4d21316b1c5dd37271b5bf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff59ee1c1eebc949692edc8ac225fb6"><td class="memItemLeft" align="right" valign="top"><a id="gaeff59ee1c1eebc949692edc8ac225fb6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_NORMAL_READ_MODE</b>&#160;&#160;&#160;FLCTL_BANK0_RDCTL_RD_MODE_0</td></tr>
<tr class="separator:gaeff59ee1c1eebc949692edc8ac225fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedfb31dfeaf192afdf606139c0af7843"><td class="memItemLeft" align="right" valign="top"><a id="gaedfb31dfeaf192afdf606139c0af7843"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_MARGIN0_READ_MODE</b>&#160;&#160;&#160;FLCTL_BANK0_RDCTL_RD_MODE_1</td></tr>
<tr class="separator:gaedfb31dfeaf192afdf606139c0af7843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92e9a68d0dc8e91665e1c53f4cb3fc9a"><td class="memItemLeft" align="right" valign="top"><a id="ga92e9a68d0dc8e91665e1c53f4cb3fc9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_MARGIN1_READ_MODE</b>&#160;&#160;&#160;FLCTL_BANK0_RDCTL_RD_MODE_2</td></tr>
<tr class="separator:ga92e9a68d0dc8e91665e1c53f4cb3fc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga031a2e7e03d6d5b165d01f1ab6abbe61"><td class="memItemLeft" align="right" valign="top"><a id="ga031a2e7e03d6d5b165d01f1ab6abbe61"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_PROGRAM_VERIFY_READ_MODE</b>&#160;&#160;&#160;FLCTL_BANK0_RDCTL_RD_MODE_3</td></tr>
<tr class="separator:ga031a2e7e03d6d5b165d01f1ab6abbe61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12ab198bf692d2b521ffd0b3caf7d1cd"><td class="memItemLeft" align="right" valign="top"><a id="ga12ab198bf692d2b521ffd0b3caf7d1cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_ERASE_VERIFY_READ_MODE</b>&#160;&#160;&#160;FLCTL_BANK0_RDCTL_RD_MODE_4</td></tr>
<tr class="separator:ga12ab198bf692d2b521ffd0b3caf7d1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ec0c3a589a1d37c8dea612d24c2935"><td class="memItemLeft" align="right" valign="top"><a id="gae1ec0c3a589a1d37c8dea612d24c2935"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_LEAKAGE_VERIFY_READ_MODE</b>&#160;&#160;&#160;FLCTL_BANK0_RDCTL_RD_MODE_5</td></tr>
<tr class="separator:gae1ec0c3a589a1d37c8dea612d24c2935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1153d85ad5615775daab576f3acb4eaa"><td class="memItemLeft" align="right" valign="top"><a id="ga1153d85ad5615775daab576f3acb4eaa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_MARGIN0B_READ_MODE</b>&#160;&#160;&#160;FLCTL_BANK0_RDCTL_RD_MODE_9</td></tr>
<tr class="separator:ga1153d85ad5615775daab576f3acb4eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d2ae53e393bf6281cb240ac1af1c2c5"><td class="memItemLeft" align="right" valign="top"><a id="ga6d2ae53e393bf6281cb240ac1af1c2c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_MARGIN1B_READ_MODE</b>&#160;&#160;&#160;FLCTL_BANK0_RDCTL_RD_MODE_10</td></tr>
<tr class="separator:ga6d2ae53e393bf6281cb240ac1af1c2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37f1beb632c686451d1749f572d091eb"><td class="memItemLeft" align="right" valign="top"><a id="ga37f1beb632c686451d1749f572d091eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_PRGBRSTCTLSTAT_BURSTSTATUS_COMPLETE</b>&#160;&#160;&#160;FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_7</td></tr>
<tr class="separator:ga37f1beb632c686451d1749f572d091eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36de1c500d46e10ce6546c5d5cee96e5"><td class="memItemLeft" align="right" valign="top"><a id="ga36de1c500d46e10ce6546c5d5cee96e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_BANK0</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:ga36de1c500d46e10ce6546c5d5cee96e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cbfd965079d38903e7e489d187fbbf9"><td class="memItemLeft" align="right" valign="top"><a id="ga7cbfd965079d38903e7e489d187fbbf9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_BANK1</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga7cbfd965079d38903e7e489d187fbbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefee7092bf9eaf28ca95452558e1bfb4"><td class="memItemLeft" align="right" valign="top"><a id="gaefee7092bf9eaf28ca95452558e1bfb4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_DATA_READ</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gaefee7092bf9eaf28ca95452558e1bfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a8dd7dc00132c4ae465dd6799825913"><td class="memItemLeft" align="right" valign="top"><a id="ga2a8dd7dc00132c4ae465dd6799825913"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_INSTRUCTION_FETCH</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga2a8dd7dc00132c4ae465dd6799825913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ba8dddf1f12adbac7e84e7f47d8823"><td class="memItemLeft" align="right" valign="top"><a id="ga58ba8dddf1f12adbac7e84e7f47d8823"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_MAIN_MEMORY_SPACE_BANK0</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga58ba8dddf1f12adbac7e84e7f47d8823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b725f851871175beced0a98037394eb"><td class="memItemLeft" align="right" valign="top"><a id="ga4b725f851871175beced0a98037394eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_MAIN_MEMORY_SPACE_BANK1</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ga4b725f851871175beced0a98037394eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0863f93f242992b07aa0f8ebc6eb10d"><td class="memItemLeft" align="right" valign="top"><a id="gae0863f93f242992b07aa0f8ebc6eb10d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_INFO_MEMORY_SPACE_BANK0</b>&#160;&#160;&#160;0x03</td></tr>
<tr class="separator:gae0863f93f242992b07aa0f8ebc6eb10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad886753a755e4948cd3518ab5208692d"><td class="memItemLeft" align="right" valign="top"><a id="gad886753a755e4948cd3518ab5208692d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_INFO_MEMORY_SPACE_BANK1</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:gad886753a755e4948cd3518ab5208692d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa345ac0a7037121568f1a52a3c9d4004"><td class="memItemLeft" align="right" valign="top"><a id="gaa345ac0a7037121568f1a52a3c9d4004"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_MAIN_SPACE</b>&#160;&#160;&#160;FLCTL_RDBRST_CTLSTAT_MEM_TYPE_0</td></tr>
<tr class="separator:gaa345ac0a7037121568f1a52a3c9d4004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf80f152586eedcb26e00cfe37704d06"><td class="memItemLeft" align="right" valign="top"><a id="gacf80f152586eedcb26e00cfe37704d06"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_INFO_SPACE</b>&#160;&#160;&#160;FLCTL_RDBRST_CTLSTAT_MEM_TYPE_1</td></tr>
<tr class="separator:gacf80f152586eedcb26e00cfe37704d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4af59fe0d77ec1327108df45d5d6f2"><td class="memItemLeft" align="right" valign="top"><a id="gaaf4af59fe0d77ec1327108df45d5d6f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_1_PATTERN</b>&#160;&#160;&#160;FLCTL_RDBRST_CTLSTAT_DATA_CMP</td></tr>
<tr class="separator:gaaf4af59fe0d77ec1327108df45d5d6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358986e70f0b42f35efe09d190e364ed"><td class="memItemLeft" align="right" valign="top"><a id="ga358986e70f0b42f35efe09d190e364ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_0_PATTERN</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:ga358986e70f0b42f35efe09d190e364ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c91b925c5dae7ab9c0b210d9f5e3290"><td class="memItemLeft" align="right" valign="top"><a id="ga4c91b925c5dae7ab9c0b210d9f5e3290"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR0</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT0</td></tr>
<tr class="separator:ga4c91b925c5dae7ab9c0b210d9f5e3290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4457557c78b3a2c19879acd8cea46c2"><td class="memItemLeft" align="right" valign="top"><a id="gae4457557c78b3a2c19879acd8cea46c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR1</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT1</td></tr>
<tr class="separator:gae4457557c78b3a2c19879acd8cea46c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad933e80a31cbb50c74a1ef990c1a4a3e"><td class="memItemLeft" align="right" valign="top"><a id="gad933e80a31cbb50c74a1ef990c1a4a3e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR2</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT2</td></tr>
<tr class="separator:gad933e80a31cbb50c74a1ef990c1a4a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b33798d8e1a94773ff63865d0edab5"><td class="memItemLeft" align="right" valign="top"><a id="ga51b33798d8e1a94773ff63865d0edab5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR3</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT3</td></tr>
<tr class="separator:ga51b33798d8e1a94773ff63865d0edab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1228753eb2eea0f96e39d4f019c0c17b"><td class="memItemLeft" align="right" valign="top"><a id="ga1228753eb2eea0f96e39d4f019c0c17b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR4</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT4</td></tr>
<tr class="separator:ga1228753eb2eea0f96e39d4f019c0c17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7b6b8b1602374df1da5198ec15b824"><td class="memItemLeft" align="right" valign="top"><a id="gaea7b6b8b1602374df1da5198ec15b824"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR5</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT5</td></tr>
<tr class="separator:gaea7b6b8b1602374df1da5198ec15b824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga071a68ba40b9ab4133b75f5ce4a3402a"><td class="memItemLeft" align="right" valign="top"><a id="ga071a68ba40b9ab4133b75f5ce4a3402a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR6</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT6</td></tr>
<tr class="separator:ga071a68ba40b9ab4133b75f5ce4a3402a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91746c2359832e41f3045f500cbfb9d"><td class="memItemLeft" align="right" valign="top"><a id="gab91746c2359832e41f3045f500cbfb9d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR7</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT7</td></tr>
<tr class="separator:gab91746c2359832e41f3045f500cbfb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e02d10099a20f5fa3af324f0fe1fb5f"><td class="memItemLeft" align="right" valign="top"><a id="ga0e02d10099a20f5fa3af324f0fe1fb5f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR8</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT8</td></tr>
<tr class="separator:ga0e02d10099a20f5fa3af324f0fe1fb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f13941a7117fe0fe24967d1b9400483"><td class="memItemLeft" align="right" valign="top"><a id="ga8f13941a7117fe0fe24967d1b9400483"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR9</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT9</td></tr>
<tr class="separator:ga8f13941a7117fe0fe24967d1b9400483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08226153c6c0b3be68b28f16fa133b4d"><td class="memItemLeft" align="right" valign="top"><a id="ga08226153c6c0b3be68b28f16fa133b4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR10</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT10</td></tr>
<tr class="separator:ga08226153c6c0b3be68b28f16fa133b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cba0aa03c86ebdfd4bf5632ae971b95"><td class="memItemLeft" align="right" valign="top"><a id="ga2cba0aa03c86ebdfd4bf5632ae971b95"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR11</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT11</td></tr>
<tr class="separator:ga2cba0aa03c86ebdfd4bf5632ae971b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8494c124066e435f018ed063afa04332"><td class="memItemLeft" align="right" valign="top"><a id="ga8494c124066e435f018ed063afa04332"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR12</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT12</td></tr>
<tr class="separator:ga8494c124066e435f018ed063afa04332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5023fb0ca59d3eb7c7e1f4cdd95261a8"><td class="memItemLeft" align="right" valign="top"><a id="ga5023fb0ca59d3eb7c7e1f4cdd95261a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR13</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT13</td></tr>
<tr class="separator:ga5023fb0ca59d3eb7c7e1f4cdd95261a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6889465a911afb34076528a4fea76a2"><td class="memItemLeft" align="right" valign="top"><a id="gac6889465a911afb34076528a4fea76a2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR14</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT14</td></tr>
<tr class="separator:gac6889465a911afb34076528a4fea76a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0398eb225c41f1b55ef1be92ff54ebb8"><td class="memItemLeft" align="right" valign="top"><a id="ga0398eb225c41f1b55ef1be92ff54ebb8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR15</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT15</td></tr>
<tr class="separator:ga0398eb225c41f1b55ef1be92ff54ebb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7570aca357a389f4b160895dffdbd2"><td class="memItemLeft" align="right" valign="top"><a id="ga2e7570aca357a389f4b160895dffdbd2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR16</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT16</td></tr>
<tr class="separator:ga2e7570aca357a389f4b160895dffdbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb644fadcb04ce31dc116be4f8a140f"><td class="memItemLeft" align="right" valign="top"><a id="ga8bb644fadcb04ce31dc116be4f8a140f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR17</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT17</td></tr>
<tr class="separator:ga8bb644fadcb04ce31dc116be4f8a140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7fc0ebc5957a3ef05abb197f372ce69"><td class="memItemLeft" align="right" valign="top"><a id="gaa7fc0ebc5957a3ef05abb197f372ce69"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR18</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT18</td></tr>
<tr class="separator:gaa7fc0ebc5957a3ef05abb197f372ce69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad026b02b23dd01334d9e49d8cb582d0c"><td class="memItemLeft" align="right" valign="top"><a id="gad026b02b23dd01334d9e49d8cb582d0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR19</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT19</td></tr>
<tr class="separator:gad026b02b23dd01334d9e49d8cb582d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76d57e01410e52e7ed9f7ed9e1db5b7"><td class="memItemLeft" align="right" valign="top"><a id="gab76d57e01410e52e7ed9f7ed9e1db5b7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR20</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT20</td></tr>
<tr class="separator:gab76d57e01410e52e7ed9f7ed9e1db5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8129cf6aec39eaadbba5fe25e3b43350"><td class="memItemLeft" align="right" valign="top"><a id="ga8129cf6aec39eaadbba5fe25e3b43350"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR21</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT21</td></tr>
<tr class="separator:ga8129cf6aec39eaadbba5fe25e3b43350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa270500b1446b87f1e18b4f7700c4ef8"><td class="memItemLeft" align="right" valign="top"><a id="gaa270500b1446b87f1e18b4f7700c4ef8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR22</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT22</td></tr>
<tr class="separator:gaa270500b1446b87f1e18b4f7700c4ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabffe0ea3b497bea5f54909c4f43861a6"><td class="memItemLeft" align="right" valign="top"><a id="gabffe0ea3b497bea5f54909c4f43861a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR23</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT23</td></tr>
<tr class="separator:gabffe0ea3b497bea5f54909c4f43861a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe498071150f1c943056c45cb837c59e"><td class="memItemLeft" align="right" valign="top"><a id="gabe498071150f1c943056c45cb837c59e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR24</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT24</td></tr>
<tr class="separator:gabe498071150f1c943056c45cb837c59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65d2920a538e706f9f8ae66e011e10f"><td class="memItemLeft" align="right" valign="top"><a id="gab65d2920a538e706f9f8ae66e011e10f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR25</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT25</td></tr>
<tr class="separator:gab65d2920a538e706f9f8ae66e011e10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d29e822232e735f5c40c0e140406b4"><td class="memItemLeft" align="right" valign="top"><a id="ga07d29e822232e735f5c40c0e140406b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR26</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT26</td></tr>
<tr class="separator:ga07d29e822232e735f5c40c0e140406b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa47b3d3101f6c11f77203f39f79296b"><td class="memItemLeft" align="right" valign="top"><a id="gaaa47b3d3101f6c11f77203f39f79296b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR27</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT27</td></tr>
<tr class="separator:gaaa47b3d3101f6c11f77203f39f79296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f336c66dac701ae8e2a3975b500794"><td class="memItemLeft" align="right" valign="top"><a id="ga44f336c66dac701ae8e2a3975b500794"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR28</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT28</td></tr>
<tr class="separator:ga44f336c66dac701ae8e2a3975b500794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf78485be786b754115ca4a377fda2647"><td class="memItemLeft" align="right" valign="top"><a id="gaf78485be786b754115ca4a377fda2647"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR29</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT29</td></tr>
<tr class="separator:gaf78485be786b754115ca4a377fda2647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa3d48c595b28d6d14cf67995bea8c3b"><td class="memItemLeft" align="right" valign="top"><a id="gafa3d48c595b28d6d14cf67995bea8c3b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR30</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT30</td></tr>
<tr class="separator:gafa3d48c595b28d6d14cf67995bea8c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad44aa4697b3bc300336227ade8d0b62f"><td class="memItemLeft" align="right" valign="top"><a id="gad44aa4697b3bc300336227ade8d0b62f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR31</b>&#160;&#160;&#160;FLCTL_BANK0_MAIN_WEPROT_PROT31</td></tr>
<tr class="separator:gad44aa4697b3bc300336227ade8d0b62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c2278aac5cc427f434626cf395ea1d"><td class="memItemLeft" align="right" valign="top"><a id="gab9c2278aac5cc427f434626cf395ea1d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_NOVER</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gab9c2278aac5cc427f434626cf395ea1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a7de832860c948a30e9b82443a6207"><td class="memItemLeft" align="right" valign="top"><a id="ga69a7de832860c948a30e9b82443a6207"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_BURSTPOST</b>&#160;&#160;&#160;FLCTL_PRGBRST_CTLSTAT_AUTO_PST</td></tr>
<tr class="separator:ga69a7de832860c948a30e9b82443a6207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1debb820849f57c80b201383ec1f8390"><td class="memItemLeft" align="right" valign="top"><a id="ga1debb820849f57c80b201383ec1f8390"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_BURSTPRE</b>&#160;&#160;&#160;FLCTL_PRGBRST_CTLSTAT_AUTO_PRE</td></tr>
<tr class="separator:ga1debb820849f57c80b201383ec1f8390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecae7d99fb419f0800dedbf9c2476310"><td class="memItemLeft" align="right" valign="top"><a id="gaecae7d99fb419f0800dedbf9c2476310"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_REGPRE</b>&#160;&#160;&#160;FLCTL_PRG_CTLSTAT_VER_PRE</td></tr>
<tr class="separator:gaecae7d99fb419f0800dedbf9c2476310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga090e0bf6677ab0ad072f588eccefee6e"><td class="memItemLeft" align="right" valign="top"><a id="ga090e0bf6677ab0ad072f588eccefee6e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_REGPOST</b>&#160;&#160;&#160;FLCTL_PRG_CTLSTAT_VER_PST</td></tr>
<tr class="separator:ga090e0bf6677ab0ad072f588eccefee6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b2dd1736ee5e81719965971cb0de2f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_FULLVER</b></td></tr>
<tr class="separator:ga38b2dd1736ee5e81719965971cb0de2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf166d3ee4362bb65722810aae05af59"><td class="memItemLeft" align="right" valign="top"><a id="gabf166d3ee4362bb65722810aae05af59"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_COLLATED_WRITE_MODE</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:gabf166d3ee4362bb65722810aae05af59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ed565fa83a52a175fed9e5b0d041320"><td class="memItemLeft" align="right" valign="top"><a id="ga5ed565fa83a52a175fed9e5b0d041320"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_IMMEDIATE_WRITE_MODE</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ga5ed565fa83a52a175fed9e5b0d041320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacacdaf6abd47b9fe4fade33d0cd5231f"><td class="memItemLeft" align="right" valign="top"><a id="gacacdaf6abd47b9fe4fade33d0cd5231f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__INFO_FLASH_TECH_START__</b>&#160;&#160;&#160;0x00200000</td></tr>
<tr class="separator:gacacdaf6abd47b9fe4fade33d0cd5231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec6ddc0b9f9f00f1d8347b8cc9bb0584"><td class="memItemLeft" align="right" valign="top"><a id="gaec6ddc0b9f9f00f1d8347b8cc9bb0584"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__INFO_FLASH_TECH_MIDDLE__</b>&#160;&#160;&#160;0x00202000</td></tr>
<tr class="separator:gaec6ddc0b9f9f00f1d8347b8cc9bb0584"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab709654d4662b59433700a42e508157f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gab709654d4662b59433700a42e508157f">FlashCtl_getMemoryInfo</a> (uint32_t addr, uint32_t *sectorNum, uint32_t *bankNum)</td></tr>
<tr class="separator:gab709654d4662b59433700a42e508157f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc6eea114cce812f5efc26918c20e2fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gadc6eea114cce812f5efc26918c20e2fb">FlashCtl_enableReadBuffering</a> (uint_fast8_t memoryBank, uint_fast8_t accessMethod)</td></tr>
<tr class="separator:gadc6eea114cce812f5efc26918c20e2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c3f89d48453e05d640e151e84ad29ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga9c3f89d48453e05d640e151e84ad29ae">FlashCtl_disableReadBuffering</a> (uint_fast8_t memoryBank, uint_fast8_t accessMethod)</td></tr>
<tr class="separator:ga9c3f89d48453e05d640e151e84ad29ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a5ee1d72e3518a990de007b8cc3d93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga42a5ee1d72e3518a990de007b8cc3d93">FlashCtl_unprotectSector</a> (uint_fast8_t memorySpace, uint32_t sectorMask)</td></tr>
<tr class="separator:ga42a5ee1d72e3518a990de007b8cc3d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga643479a252e15ddf5d14ee15f5725a01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga643479a252e15ddf5d14ee15f5725a01">FlashCtl_protectSector</a> (uint_fast8_t memorySpace, uint32_t sectorMask)</td></tr>
<tr class="separator:ga643479a252e15ddf5d14ee15f5725a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6be10c4bc7408b5775593d5a0df9fdec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga6be10c4bc7408b5775593d5a0df9fdec">FlashCtl_isSectorProtected</a> (uint_fast8_t memorySpace, uint32_t sector)</td></tr>
<tr class="separator:ga6be10c4bc7408b5775593d5a0df9fdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfc54f0fae16bba79bd2e9d8be51dd82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gadfc54f0fae16bba79bd2e9d8be51dd82">FlashCtl_verifyMemory</a> (void *verifyAddr, uint32_t length, uint_fast8_t pattern)</td></tr>
<tr class="separator:gadfc54f0fae16bba79bd2e9d8be51dd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c744d750a4cc1b40355615a15ffc37c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga2c744d750a4cc1b40355615a15ffc37c">FlashCtl_performMassErase</a> (void)</td></tr>
<tr class="separator:ga2c744d750a4cc1b40355615a15ffc37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7af4b807675d7a14f73321aab151075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gaa7af4b807675d7a14f73321aab151075">FlashCtl_initiateMassErase</a> (void)</td></tr>
<tr class="separator:gaa7af4b807675d7a14f73321aab151075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e48384c1eda5195d05ff18bf07d4088"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga7e48384c1eda5195d05ff18bf07d4088">FlashCtl_eraseSector</a> (uint32_t addr)</td></tr>
<tr class="separator:ga7e48384c1eda5195d05ff18bf07d4088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eac39f363b924ee781af7ffacd08392"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga9eac39f363b924ee781af7ffacd08392">FlashCtl_programMemory</a> (void *src, void *dest, uint32_t length)</td></tr>
<tr class="separator:ga9eac39f363b924ee781af7ffacd08392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga686737103aa0cc666f50c9d17a1c01df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga686737103aa0cc666f50c9d17a1c01df">FlashCtl_setProgramVerification</a> (uint32_t verificationSetting)</td></tr>
<tr class="separator:ga686737103aa0cc666f50c9d17a1c01df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5217f1a9ed48f0cc754170a828280ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga5217f1a9ed48f0cc754170a828280ce6">FlashCtl_clearProgramVerification</a> (uint32_t verificationSetting)</td></tr>
<tr class="separator:ga5217f1a9ed48f0cc754170a828280ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd5b54a4f9b839621ff6607ac23ca353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gadd5b54a4f9b839621ff6607ac23ca353">FlashCtl_enableWordProgramming</a> (uint32_t mode)</td></tr>
<tr class="separator:gadd5b54a4f9b839621ff6607ac23ca353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8045fc2b9ad3bf9a177883e05d92a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga8b8045fc2b9ad3bf9a177883e05d92a1">FlashCtl_disableWordProgramming</a> (void)</td></tr>
<tr class="separator:ga8b8045fc2b9ad3bf9a177883e05d92a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a93ffae99bb1b7d511225062e327d0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga19a93ffae99bb1b7d511225062e327d0">FlashCtl_isWordProgrammingEnabled</a> (void)</td></tr>
<tr class="separator:ga19a93ffae99bb1b7d511225062e327d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bcf0c3e5893072d14c3ff2aabb76f1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga8bcf0c3e5893072d14c3ff2aabb76f1a">FlashCtl_setReadMode</a> (uint32_t flashBank, uint32_t readMode)</td></tr>
<tr class="separator:ga8bcf0c3e5893072d14c3ff2aabb76f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4defdb6bbaeb84d8bf735da8edbdd3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gaab4defdb6bbaeb84d8bf735da8edbdd3">FlashCtl_getReadMode</a> (uint32_t flashBank)</td></tr>
<tr class="separator:gaab4defdb6bbaeb84d8bf735da8edbdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf728ba4d0b0394c031d5d4ff2e7f74f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gaf728ba4d0b0394c031d5d4ff2e7f74f4">FlashCtl_setWaitState</a> (uint32_t bank, uint32_t waitState)</td></tr>
<tr class="separator:gaf728ba4d0b0394c031d5d4ff2e7f74f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccfa6143be8c5c732d153343b1bb905"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gaaccfa6143be8c5c732d153343b1bb905">FlashCtl_getWaitState</a> (uint32_t bank)</td></tr>
<tr class="separator:gaaccfa6143be8c5c732d153343b1bb905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf4ab765e78a4a2a9207f26a345449b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga0bf4ab765e78a4a2a9207f26a345449b">FlashCtl_enableInterrupt</a> (uint32_t flags)</td></tr>
<tr class="separator:ga0bf4ab765e78a4a2a9207f26a345449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca14d1226c93d4bc404c6ae8c4ed501a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gaca14d1226c93d4bc404c6ae8c4ed501a">FlashCtl_disableInterrupt</a> (uint32_t flags)</td></tr>
<tr class="separator:gaca14d1226c93d4bc404c6ae8c4ed501a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82886bf7ae213c0ceb7e21455093386d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga82886bf7ae213c0ceb7e21455093386d">FlashCtl_getEnabledInterruptStatus</a> (void)</td></tr>
<tr class="separator:ga82886bf7ae213c0ceb7e21455093386d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28009bfbf2fed4759169ab884fa3c862"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga28009bfbf2fed4759169ab884fa3c862">FlashCtl_getInterruptStatus</a> (void)</td></tr>
<tr class="separator:ga28009bfbf2fed4759169ab884fa3c862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b532f44ea6c98ee913129d18e6f55f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga90b532f44ea6c98ee913129d18e6f55f">FlashCtl_clearInterruptFlag</a> (uint32_t flags)</td></tr>
<tr class="separator:ga90b532f44ea6c98ee913129d18e6f55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c2d23af4d0bf1a6cdcea8d88121b738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga2c2d23af4d0bf1a6cdcea8d88121b738">FlashCtl_registerInterrupt</a> (void(*intHandler)(void))</td></tr>
<tr class="separator:ga2c2d23af4d0bf1a6cdcea8d88121b738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga693049351805d98fd704c6c33b907c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga693049351805d98fd704c6c33b907c53">FlashCtl_unregisterInterrupt</a> (void)</td></tr>
<tr class="separator:ga693049351805d98fd704c6c33b907c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c37f9455c2f393bd88421a1b784dcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga21c37f9455c2f393bd88421a1b784dcf">FlashCtl_initiateSectorErase</a> (uint32_t addr)</td></tr>
<tr class="separator:ga21c37f9455c2f393bd88421a1b784dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9be68c642b38e05a236a1d1d5843a4d"><td class="memItemLeft" align="right" valign="top"><a id="gab9be68c642b38e05a236a1d1d5843a4d"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>__FlashCtl_remaskData8Post</b> (uint8_t data, uint32_t addr)</td></tr>
<tr class="separator:gab9be68c642b38e05a236a1d1d5843a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacde0c1f43dbba627d84cf052a5798150"><td class="memItemLeft" align="right" valign="top"><a id="gacde0c1f43dbba627d84cf052a5798150"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>__FlashCtl_remaskData8Pre</b> (uint8_t data, uint32_t addr)</td></tr>
<tr class="separator:gacde0c1f43dbba627d84cf052a5798150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94777392054bafb0020556a308223701"><td class="memItemLeft" align="right" valign="top"><a id="ga94777392054bafb0020556a308223701"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>__FlashCtl_remaskData32Post</b> (uint32_t data, uint32_t addr)</td></tr>
<tr class="separator:ga94777392054bafb0020556a308223701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga611903ab168528224d1bf68840b9bedc"><td class="memItemLeft" align="right" valign="top"><a id="ga611903ab168528224d1bf68840b9bedc"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>__FlashCtl_remaskData32Pre</b> (uint32_t data, uint32_t addr)</td></tr>
<tr class="separator:ga611903ab168528224d1bf68840b9bedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a090837d81cb71ba9e345f5997e629"><td class="memItemLeft" align="right" valign="top"><a id="gaa7a090837d81cb71ba9e345f5997e629"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__FlashCtl_remaskBurstDataPost</b> (uint32_t addr, uint32_t size)</td></tr>
<tr class="separator:gaa7a090837d81cb71ba9e345f5997e629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32695b47cb5f262d06b2aad5bf7ed514"><td class="memItemLeft" align="right" valign="top"><a id="ga32695b47cb5f262d06b2aad5bf7ed514"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__FlashCtl_remaskBurstDataPre</b> (uint32_t addr, uint32_t size)</td></tr>
<tr class="separator:ga32695b47cb5f262d06b2aad5bf7ed514"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga38b2dd1736ee5e81719965971cb0de2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38b2dd1736ee5e81719965971cb0de2f">&#9670;&nbsp;</a></span>FLASH_FULLVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_FULLVER</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                    (FLCTL_PRGBRST_CTLSTAT_AUTO_PST |                        \</div>
<div class="line">                    FLCTL_PRGBRST_CTLSTAT_AUTO_PRE | FLCTL_PRG_CTLSTAT_VER_PRE \</div>
<div class="line">                    | FLCTL_PRG_CTLSTAT_VER_PST)</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga90b532f44ea6c98ee913129d18e6f55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90b532f44ea6c98ee913129d18e6f55f">&#9670;&nbsp;</a></span>FlashCtl_clearInterruptFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_clearInterruptFlag </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears flash system interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>is a bit mask of the interrupt sources to be cleared. Must be a logical OR of:<ul>
<li><b>FLASH_PROGRAM_ERROR</b>,</li>
<li><b>FLASH_BENCHMARK_INT</b>,</li>
<li><b>FLASH_ERASE_COMPLETE</b>,</li>
<li><b>FLASH_BRSTPRGM_COMPLETE</b>,</li>
<li><b>FLASH_WRDPRGM_COMPLETE</b>,</li>
<li><b>FLASH_POSTVERIFY_FAILED</b>,</li>
<li><b>FLASH_PREVERIFY_FAILED</b>,</li>
<li><b>FLASH_BRSTRDCMP_COMPLETE</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The specified flash system interrupt sources are cleared, so that they no longer assert. This function must be called in the interrupt handler to keep it from being called again immediately upon exit.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd>
<dd>
The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga5217f1a9ed48f0cc754170a828280ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5217f1a9ed48f0cc754170a828280ce6">&#9670;&nbsp;</a></span>FlashCtl_clearProgramVerification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_clearProgramVerification </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>verificationSetting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears pre/post verification of burst and regular flash programming instructions. Note that this API is for advanced users that are programming their own flash drivers. The program/erase APIs are not affected by this setting and take care of the verification requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verificationSetting</td><td>Verification setting to clear. This value can be a bitwise OR of the following values:<ul>
<li><b>FLASH_BURSTPOST</b>,</li>
<li><b>FLASH_BURSTPRE</b>,</li>
<li><b>FLASH_REGPRE</b>,</li>
<li><b>FLASH_REGPOST</b> </li>
<li><b>FLASH_NOVER</b> No verification enabled</li>
<li><b>FLASH_FULLVER</b> Full verification enabled</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="gaca14d1226c93d4bc404c6ae8c4ed501a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca14d1226c93d4bc404c6ae8c4ed501a">&#9670;&nbsp;</a></span>FlashCtl_disableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables individual flash system interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>is a bit mask of the interrupt sources to be disabled. Must be a logical OR of:<ul>
<li><b>FLASH_PROGRAM_ERROR</b>,</li>
<li><b>FLASH_BENCHMARK_INT</b>,</li>
<li><b>FLASH_ERASE_COMPLETE</b>,</li>
<li><b>FLASH_BRSTPRGM_COMPLETE</b>,</li>
<li><b>FLASH_WRDPRGM_COMPLETE</b>,</li>
<li><b>FLASH_POSTVERIFY_FAILED</b>,</li>
<li><b>FLASH_PREVERIFY_FAILED</b>,</li>
<li><b>FLASH_BRSTRDCMP_COMPLETE</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated flash system interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga9c3f89d48453e05d640e151e84ad29ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c3f89d48453e05d640e151e84ad29ae">&#9670;&nbsp;</a></span>FlashCtl_disableReadBuffering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_disableReadBuffering </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>memoryBank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>accessMethod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables read buffering on accesses to a specified bank of flash memory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoryBank</td><td>is the value of the memory bank to disable read buffering. Must be only one of the following values:<ul>
<li><b>FLASH_BANK0</b>,</li>
<li><b>FLASH_BANK1</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">accessMethod</td><td>is the value of the access type to disable read buffering. Must ne only one of the following values:<ul>
<li><b>FLASH_DATA_READ</b>,</li>
<li><b>FLASH_INSTRUCTION_FETCH</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga8b8045fc2b9ad3bf9a177883e05d92a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b8045fc2b9ad3bf9a177883e05d92a1">&#9670;&nbsp;</a></span>FlashCtl_disableWordProgramming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_disableWordProgramming </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables word programming of flash memory.</p>
<p>Refer to FlashCtl_enableWordProgramming and the user's guide for description on the difference between full word and immediate programming</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga0bf4ab765e78a4a2a9207f26a345449b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf4ab765e78a4a2a9207f26a345449b">&#9670;&nbsp;</a></span>FlashCtl_enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables individual flash control interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>is a bit mask of the interrupt sources to be enabled. Must be a logical OR of:<ul>
<li><b>FLASH_PROGRAM_ERROR</b>,</li>
<li><b>FLASH_BENCHMARK_INT</b>,</li>
<li><b>FLASH_ERASE_COMPLETE</b>,</li>
<li><b>FLASH_BRSTPRGM_COMPLETE</b>,</li>
<li><b>FLASH_WRDPRGM_COMPLETE</b>,</li>
<li><b>FLASH_POSTVERIFY_FAILED</b>,</li>
<li><b>FLASH_PREVERIFY_FAILED</b>,</li>
<li><b>FLASH_BRSTRDCMP_COMPLETE</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated flash system interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gadc6eea114cce812f5efc26918c20e2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc6eea114cce812f5efc26918c20e2fb">&#9670;&nbsp;</a></span>FlashCtl_enableReadBuffering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_enableReadBuffering </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>memoryBank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>accessMethod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables read buffering on accesses to a specified bank of flash memory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoryBank</td><td>is the value of the memory bank to enable read buffering. Must be only one of the following values:<ul>
<li><b>FLASH_BANK0</b>,</li>
<li><b>FLASH_BANK1</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">accessMethod</td><td>is the value of the access type to enable read buffering. Must be only one of the following values:<ul>
<li><b>FLASH_DATA_READ</b>,</li>
<li><b>FLASH_INSTRUCTION_FETCH</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gadd5b54a4f9b839621ff6607ac23ca353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd5b54a4f9b839621ff6607ac23ca353">&#9670;&nbsp;</a></span>FlashCtl_enableWordProgramming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_enableWordProgramming </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables word programming of flash memory.</p>
<p>This function will enable word programming of the flash memory and set the mode of behavior when the flash write occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The mode specifies the behavior of the flash controller when programming words to flash. In <b>FLASH_IMMEDIATE_WRITE_MODE</b>, the program operation happens immediately on the write to flash while in <b>FLASH_COLLATED_WRITE_MODE</b> the write will be delayed until a full 128-bits have been collated. Possible values include:<ul>
<li><b>FLASH_IMMEDIATE_WRITE_MODE</b> </li>
<li><b>FLASH_COLLATED_WRITE_MODE</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Refer to the user's guide for further documentation.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga7e48384c1eda5195d05ff18bf07d4088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e48384c1eda5195d05ff18bf07d4088">&#9670;&nbsp;</a></span>FlashCtl_eraseSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlashCtl_eraseSector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases a sector of MAIN or INFO flash memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The start of the sector to erase. Note that with flash, the minimum allowed size that can be erased is a flash sector (which is 4KB on the MSP432 family). If an address is provided to this function which is not on a 4KB boundary, the entire sector will still be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is blocking and will not exit until operation has either completed or failed due to an error. Furthermore, given the complex verification requirements of the flash controller, master interrupts are disabled throughout execution of this function. The original interrupt context is saved at the start of execution and restored prior to exit of the API.</dd>
<dd>
Due to the hardware limitations of the flash controller, this function cannot erase a memory adress in the same flash bank that it is executing from. If using the ROM version of this API (by using the (ROM_ or MAP_ prefixes) this is a don't care, however if this API resides in flash then special care needs to be taken to ensure no code execution or reads happen in the flash bank being programmed while this API is being executed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if sector erase is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga82886bf7ae213c0ceb7e21455093386d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82886bf7ae213c0ceb7e21455093386d">&#9670;&nbsp;</a></span>FlashCtl_getEnabledInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FlashCtl_getEnabledInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current interrupt status masked with the enabled interrupts. This function is useful to call in ISRs to get a list of pending interrupts that are actually enabled and could have caused the ISR.</p>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt status, enumerated as a bit field of<ul>
<li><b>FLASH_PROGRAM_ERROR</b>,</li>
<li><b>FLASH_BENCHMARK_INT</b>,</li>
<li><b>FLASH_ERASE_COMPLETE</b>,</li>
<li><b>FLASH_BRSTPRGM_COMPLETE</b>,</li>
<li><b>FLASH_WRDPRGM_COMPLETE</b>,</li>
<li><b>FLASH_POSTVERIFY_FAILED</b>,</li>
<li><b>FLASH_PREVERIFY_FAILED</b>,</li>
<li><b>FLASH_BRSTRDCMP_COMPLETE</b> </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available. </dd></dl>

</div>
</div>
<a id="ga28009bfbf2fed4759169ab884fa3c862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28009bfbf2fed4759169ab884fa3c862">&#9670;&nbsp;</a></span>FlashCtl_getInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FlashCtl_getInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current interrupt status.</p>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt status, enumerated as a bit field of:<ul>
<li><b>FLASH_PROGRAM_ERROR</b>,</li>
<li><b>FLASH_BENCHMARK_INT</b>,</li>
<li><b>FLASH_ERASE_COMPLETE</b>,</li>
<li><b>FLASH_BRSTPRGM_COMPLETE</b>,</li>
<li><b>FLASH_WRDPRGM_COMPLETE</b>,</li>
<li><b>FLASH_POSTVERIFY_FAILED</b>,</li>
<li><b>FLASH_PREVERIFY_FAILED</b>,</li>
<li><b>FLASH_BRSTRDCMP_COMPLETE</b> </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available. </dd></dl>

</div>
</div>
<a id="gab709654d4662b59433700a42e508157f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab709654d4662b59433700a42e508157f">&#9670;&nbsp;</a></span>FlashCtl_getMemoryInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_getMemoryInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>sectorNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bankNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the flash bank and sector number given an address. Stores the results into the two pointers given as parameters. The user must provide a valid memory address (an address in SRAM for example will give an invalid result).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address to calculate the bank/sector information for</td></tr>
    <tr><td class="paramname">sectorNum</td><td>The sector number will be stored in here after the function completes.</td></tr>
    <tr><td class="paramname">sectorNum</td><td>The bank number will be stored in here after the function completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For simplicity, this API only works with address in MAIN flash memory. For calculating the sector/bank number of an address in info memory, please refer to your device datasheet/</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaab4defdb6bbaeb84d8bf735da8edbdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab4defdb6bbaeb84d8bf735da8edbdd3">&#9670;&nbsp;</a></span>FlashCtl_getReadMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FlashCtl_getReadMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flashBank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the flash read mode to be used by default flash read operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flashBank</td><td>Flash bank to set read mode for. Valid values are:<ul>
<li><b>FLASH_BANK0</b> </li>
<li><b>FLASH_BANK1</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the read mode to set. Valid values are:<ul>
<li><b>FLASH_NORMAL_READ_MODE</b>,</li>
<li><b>FLASH_MARGIN0_READ_MODE</b>,</li>
<li><b>FLASH_MARGIN1_READ_MODE</b>,</li>
<li><b>FLASH_PROGRAM_VERIFY_READ_MODE</b>,</li>
<li><b>FLASH_ERASE_VERIFY_READ_MODE</b>,</li>
<li><b>FLASH_LEAKAGE_VERIFY_READ_MODE</b>,</li>
<li><b>FLASH_MARGIN0B_READ_MODE</b>,</li>
<li><b>FLASH_MARGIN1B_READ_MODE</b> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaaccfa6143be8c5c732d153343b1bb905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaccfa6143be8c5c732d153343b1bb905">&#9670;&nbsp;</a></span>FlashCtl_getWaitState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FlashCtl_getWaitState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set number of flash wait states for the given flash bank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flashBank</td><td>Flash bank to set wait state for. Valid values are:<ul>
<li><b>FLASH_BANK0</b> </li>
<li><b>FLASH_BANK1</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wait state setting for the specified flash bank </dd></dl>

</div>
</div>
<a id="gaa7af4b807675d7a14f73321aab151075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7af4b807675d7a14f73321aab151075">&#9670;&nbsp;</a></span>FlashCtl_initiateMassErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_initiateMassErase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates a mass erase and returns control back to the program. This is a non-blocking function, however it is the user's responsibility to perform the necessary verification requirements after the interrupt is set to signify completion.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga21c37f9455c2f393bd88421a1b784dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21c37f9455c2f393bd88421a1b784dcf">&#9670;&nbsp;</a></span>FlashCtl_initiateSectorErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_initiateSectorErase </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates a sector erase of MAIN or INFO flash memory. Note that this function simply initaites the sector erase, but does no verification which is required by the flash controller. The user must manually set and enable interrupts on the flash controller to fire on erase completion and then use the FlashCtl_verifyMemory function to verify that the sector was actually erased</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The start of the sector to erase. Note that with flash, the minimum allowed size that can be erased is a flash sector (which is 4KB on the MSP432 family). If an address is provided to this function which is not on a 4KB boundary, the entire sector will still be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga6be10c4bc7408b5775593d5a0df9fdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6be10c4bc7408b5775593d5a0df9fdec">&#9670;&nbsp;</a></span>FlashCtl_isSectorProtected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlashCtl_isSectorProtected </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>memorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sector protection for given sector mask and memory space</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memorySpace</td><td>is the value of the memory bank to check for program protection. Must be only one of the following values:<ul>
<li><b>FLASH_MAIN_MEMORY_SPACE_BANK0</b>,</li>
<li><b>FLASH_MAIN_MEMORY_SPACE_BANK1</b>,</li>
<li><b>FLASH_INFO_MEMORY_SPACE_BANK0</b>,</li>
<li><b>FLASH_INFO_MEMORY_SPACE_BANK1</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">sector</td><td>is the sector to check for program protection. Must be one of the following values:<ul>
<li><b>FLASH_SECTOR0</b>,</li>
<li><b>FLASH_SECTOR1</b>,</li>
<li><b>FLASH_SECTOR2</b>,</li>
<li><b>FLASH_SECTOR3</b>,</li>
<li><b>FLASH_SECTOR4</b>,</li>
<li><b>FLASH_SECTOR5</b>,</li>
<li><b>FLASH_SECTOR6</b>,</li>
<li><b>FLASH_SECTOR7</b>,</li>
<li><b>FLASH_SECTOR8</b>,</li>
<li><b>FLASH_SECTOR9</b>,</li>
<li><b>FLASH_SECTOR10</b>,</li>
<li><b>FLASH_SECTOR11</b>,</li>
<li><b>FLASH_SECTOR12</b>,</li>
<li><b>FLASH_SECTOR13</b>,</li>
<li><b>FLASH_SECTOR14</b>,</li>
<li><b>FLASH_SECTOR15</b>,</li>
<li><b>FLASH_SECTOR16</b>,</li>
<li><b>FLASH_SECTOR17</b>,</li>
<li><b>FLASH_SECTOR18</b>,</li>
<li><b>FLASH_SECTOR19</b>,</li>
<li><b>FLASH_SECTOR20</b>,</li>
<li><b>FLASH_SECTOR21</b>,</li>
<li><b>FLASH_SECTOR22</b>,</li>
<li><b>FLASH_SECTOR23</b>,</li>
<li><b>FLASH_SECTOR24</b>,</li>
<li><b>FLASH_SECTOR25</b>,</li>
<li><b>FLASH_SECTOR26</b>,</li>
<li><b>FLASH_SECTOR27</b>,</li>
<li><b>FLASH_SECTOR28</b>,</li>
<li><b>FLASH_SECTOR29</b>,</li>
<li><b>FLASH_SECTOR30</b>,</li>
<li><b>FLASH_SECTOR31</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Note that flash sector sizes are 4KB and the number of sectors may vary depending on the specific device. Also, for INFO memory space, only sectors FLASH_SECTOR0 and FLASH_SECTOR1 will exist.</p>
<dl class="section note"><dt>Note</dt><dd>Not all devices will contain a dedicated INFO memory. Please check the device datasheet to see if your device has INFO memory available for use. For devices without INFO memory, any operation related to the INFO memory will be ignored by the hardware.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if sector protection enabled false otherwise. </dd></dl>

</div>
</div>
<a id="ga19a93ffae99bb1b7d511225062e327d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a93ffae99bb1b7d511225062e327d0">&#9670;&nbsp;</a></span>FlashCtl_isWordProgrammingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FlashCtl_isWordProgrammingEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if word programming mode is enabled (and if it is, the specific mode)</p>
<p>Refer to FlashCtl_enableWordProgramming and the user's guide for description on the difference between full word and immediate programming</p>
<dl class="section return"><dt>Returns</dt><dd>a zero value if word programming is disabled,<ul>
<li><b>FLASH_IMMEDIATE_WRITE_MODE</b> </li>
<li><b>FLASH_COLLATED_WRITE_MODE</b> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2c744d750a4cc1b40355615a15ffc37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c744d750a4cc1b40355615a15ffc37c">&#9670;&nbsp;</a></span>FlashCtl_performMassErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlashCtl_performMassErase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a mass erase on all unprotected flash sectors. Protected sectors are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function is blocking and will not exit until operation has either completed or failed due to an error. Furthermore, given the complex verification requirements of the flash controller, master interrupts are disabled throughout execution of this function. The original interrupt context is saved at the start of execution and restored prior to exit of the API.</dd>
<dd>
Due to the hardware limitations of the flash controller, this function cannot erase a memory adress in the same flash bank that it is executing from. If using the ROM version of this API (by using the (ROM_ or MAP_ prefixes) this is a don't care, however if this API resides in flash then special care needs to be taken to ensure no code execution or reads happen in the flash bank being programmed while this API is being executed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if mass erase completes successfully, false otherwise </dd></dl>

</div>
</div>
<a id="ga9eac39f363b924ee781af7ffacd08392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eac39f363b924ee781af7ffacd08392">&#9670;&nbsp;</a></span>FlashCtl_programMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlashCtl_programMemory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Program a portion of flash memory with the provided data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Pointer to the data source to program into flash</td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to the destination in flash to program</td></tr>
    <tr><td class="paramname">length</td><td>Length in bytes to program</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>There are no sector/boundary restrictions for this function, however it is encouraged to proved a start address aligned on 32-bit boundaries. Providing an unaligned address will result in unaligned data accesses and detriment efficiency.</dd>
<dd>
This function is blocking and will not exit until operation has either completed or failed due to an error. Furthermore, given the complex verification requirements of the flash controller, master interrupts are disabled throughout execution of this function. The original interrupt context is saved at the start of execution and restored prior to exit of the API.</dd>
<dd>
Due to the hardware limitations of the flash controller, this function cannot program a memory adress in the same flash bank that it is executing from. If using the ROM version of this API (by using the (ROM_ or MAP_ prefixes) this is a don't care, however if this API resides in flash then special care needs to be taken to ensure no code execution or reads happen in the flash bank being programmed while this API is being executed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the program succeeded </dd></dl>

</div>
</div>
<a id="ga643479a252e15ddf5d14ee15f5725a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga643479a252e15ddf5d14ee15f5725a01">&#9670;&nbsp;</a></span>FlashCtl_protectSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlashCtl_protectSector </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>memorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sectorMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables program protection on the given sector mask. This setting can be applied on a sector-wise bases on a given memory space (INFO or MAIN).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memorySpace</td><td>is the value of the memory bank to enable program protection. Must be only one of the following values:<ul>
<li><b>FLASH_MAIN_MEMORY_SPACE_BANK0</b>,</li>
<li><b>FLASH_MAIN_MEMORY_SPACE_BANK1</b>,</li>
<li><b>FLASH_INFO_MEMORY_SPACE_BANK0</b>,</li>
<li><b>FLASH_INFO_MEMORY_SPACE_BANK1</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">sectorMask</td><td>is a bit mask of the sectors to enable program protection. Must be a bitfield of the following values:<ul>
<li><b>FLASH_SECTOR0</b>,</li>
<li><b>FLASH_SECTOR1</b>,</li>
<li><b>FLASH_SECTOR2</b>,</li>
<li><b>FLASH_SECTOR3</b>,</li>
<li><b>FLASH_SECTOR4</b>,</li>
<li><b>FLASH_SECTOR5</b>,</li>
<li><b>FLASH_SECTOR6</b>,</li>
<li><b>FLASH_SECTOR7</b>,</li>
<li><b>FLASH_SECTOR8</b>,</li>
<li><b>FLASH_SECTOR9</b>,</li>
<li><b>FLASH_SECTOR10</b>,</li>
<li><b>FLASH_SECTOR11</b>,</li>
<li><b>FLASH_SECTOR12</b>,</li>
<li><b>FLASH_SECTOR13</b>,</li>
<li><b>FLASH_SECTOR14</b>,</li>
<li><b>FLASH_SECTOR15</b>,</li>
<li><b>FLASH_SECTOR16</b>,</li>
<li><b>FLASH_SECTOR17</b>,</li>
<li><b>FLASH_SECTOR18</b>,</li>
<li><b>FLASH_SECTOR19</b>,</li>
<li><b>FLASH_SECTOR20</b>,</li>
<li><b>FLASH_SECTOR21</b>,</li>
<li><b>FLASH_SECTOR22</b>,</li>
<li><b>FLASH_SECTOR23</b>,</li>
<li><b>FLASH_SECTOR24</b>,</li>
<li><b>FLASH_SECTOR25</b>,</li>
<li><b>FLASH_SECTOR26</b>,</li>
<li><b>FLASH_SECTOR27</b>,</li>
<li><b>FLASH_SECTOR28</b>,</li>
<li><b>FLASH_SECTOR29</b>,</li>
<li><b>FLASH_SECTOR30</b>,</li>
<li><b>FLASH_SECTOR31</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Flash sector sizes are 4KB and the number of sectors may vary depending on the specific device. Also, for INFO memory space, only sectors <b>FLASH_SECTOR0</b> and <b>FLASH_SECTOR1</b> will exist.</dd>
<dd>
Not all devices will contain a dedicated INFO memory. Please check the device datasheet to see if your device has INFO memory available for use. For devices without INFO memory, any operation related to the INFO memory will be ignored by the hardware.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if sector protection enabled false otherwise. </dd></dl>

</div>
</div>
<a id="ga2c2d23af4d0bf1a6cdcea8d88121b738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c2d23af4d0bf1a6cdcea8d88121b738">&#9670;&nbsp;</a></span>FlashCtl_registerInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_registerInterrupt </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>intHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for flash clock system interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intHandler</td><td>is a pointer to the function to be called when the clock system interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers the handler to be called when a clock system interrupt occurs. This function enables the global interrupt in the interrupt controller; specific flash controller interrupts must be enabled via <a class="el" href="group__flash__api.html#ga0bf4ab765e78a4a2a9207f26a345449b">FlashCtl_enableInterrupt()</a>. It is the interrupt handler's responsibility to clear the interrupt source via <a class="el" href="group__flash__api.html#ga90b532f44ea6c98ee913129d18e6f55f">FlashCtl_clearInterruptFlag()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#gae2a33716d48a45c7c719304d185c6620">Interrupt_registerInterrupt()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga686737103aa0cc666f50c9d17a1c01df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga686737103aa0cc666f50c9d17a1c01df">&#9670;&nbsp;</a></span>FlashCtl_setProgramVerification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_setProgramVerification </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>verificationSetting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setups pre/post verification of burst and regular flash programming instructions. Note that this API is for advanced users that are programming their own flash drivers. The program/erase APIs are not affected by this setting and take care of the verification requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verificationSetting</td><td>Verification setting to set. This value can be a bitwise OR of the following values:<ul>
<li><b>FLASH_BURSTPOST</b>,</li>
<li><b>FLASH_BURSTPRE</b>,</li>
<li><b>FLASH_REGPRE</b>,</li>
<li><b>FLASH_REGPOST</b> </li>
<li><b>FLASH_NOVER</b> No verification enabled</li>
<li><b>FLASH_FULLVER</b> Full verification enabled</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga8bcf0c3e5893072d14c3ff2aabb76f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bcf0c3e5893072d14c3ff2aabb76f1a">&#9670;&nbsp;</a></span>FlashCtl_setReadMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlashCtl_setReadMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flashBank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>readMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the flash read mode to be used by default flash read operations. Note that the proper wait states must be set prior to entering this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flashBank</td><td>Flash bank to set read mode for. Valid values are:<ul>
<li><b>FLASH_BANK0</b> </li>
<li><b>FLASH_BANK1</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">readMode</td><td>The read mode to set. Valid values are:<ul>
<li><b>FLASH_NORMAL_READ_MODE</b>,</li>
<li><b>FLASH_MARGIN0_READ_MODE</b>,</li>
<li><b>FLASH_MARGIN1_READ_MODE</b>,</li>
<li><b>FLASH_PROGRAM_VERIFY_READ_MODE</b>,</li>
<li><b>FLASH_ERASE_VERIFY_READ_MODE</b>,</li>
<li><b>FLASH_LEAKAGE_VERIFY_READ_MODE</b>,</li>
<li><b>FLASH_MARGIN0B_READ_MODE</b>,</li>
<li><b>FLASH_MARGIN1B_READ_MODE</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaf728ba4d0b0394c031d5d4ff2e7f74f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf728ba4d0b0394c031d5d4ff2e7f74f4">&#9670;&nbsp;</a></span>FlashCtl_setWaitState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_setWaitState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>waitState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the number of wait states that are used by the flash controller for read operations. When changing frequency ranges of the clock, this functions must be used in order to allow for readable flash memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitState</td><td>The number of wait states to set. Note that only bits 0-3 are used.</td></tr>
    <tr><td class="paramname">flashBank</td><td>Flash bank to set wait state for. Valid values are:<ul>
<li><b>FLASH_BANK0</b> </li>
<li><b>FLASH_BANK1</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42a5ee1d72e3518a990de007b8cc3d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42a5ee1d72e3518a990de007b8cc3d93">&#9670;&nbsp;</a></span>FlashCtl_unprotectSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlashCtl_unprotectSector </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>memorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sectorMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables program protection on the given sector mask. This setting can be applied on a sector-wise bases on a given memory space (INFO or MAIN).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memorySpace</td><td>is the value of the memory bank to disable program protection. Must be only one of the following values:<ul>
<li><b>FLASH_MAIN_MEMORY_SPACE_BANK0</b>,</li>
<li><b>FLASH_MAIN_MEMORY_SPACE_BANK1</b>,</li>
<li><b>FLASH_INFO_MEMORY_SPACE_BANK0</b>,</li>
<li><b>FLASH_INFO_MEMORY_SPACE_BANK1</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">sectorMask</td><td>is a bit mask of the sectors to disable program protection. Must be a bitfield of the following values:<ul>
<li><b>FLASH_SECTOR0</b>,</li>
<li><b>FLASH_SECTOR1</b>,</li>
<li><b>FLASH_SECTOR2</b>,</li>
<li><b>FLASH_SECTOR3</b>,</li>
<li><b>FLASH_SECTOR4</b>,</li>
<li><b>FLASH_SECTOR5</b>,</li>
<li><b>FLASH_SECTOR6</b>,</li>
<li><b>FLASH_SECTOR7</b>,</li>
<li><b>FLASH_SECTOR8</b>,</li>
<li><b>FLASH_SECTOR9</b>,</li>
<li><b>FLASH_SECTOR10</b>,</li>
<li><b>FLASH_SECTOR11</b>,</li>
<li><b>FLASH_SECTOR12</b>,</li>
<li><b>FLASH_SECTOR13</b>,</li>
<li><b>FLASH_SECTOR14</b>,</li>
<li><b>FLASH_SECTOR15</b>,</li>
<li><b>FLASH_SECTOR16</b>,</li>
<li><b>FLASH_SECTOR17</b>,</li>
<li><b>FLASH_SECTOR18</b>,</li>
<li><b>FLASH_SECTOR19</b>,</li>
<li><b>FLASH_SECTOR20</b>,</li>
<li><b>FLASH_SECTOR21</b>,</li>
<li><b>FLASH_SECTOR22</b>,</li>
<li><b>FLASH_SECTOR23</b>,</li>
<li><b>FLASH_SECTOR24</b>,</li>
<li><b>FLASH_SECTOR25</b>,</li>
<li><b>FLASH_SECTOR26</b>,</li>
<li><b>FLASH_SECTOR27</b>,</li>
<li><b>FLASH_SECTOR28</b>,</li>
<li><b>FLASH_SECTOR29</b>,</li>
<li><b>FLASH_SECTOR30</b>,</li>
<li><b>FLASH_SECTOR31</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Flash sector sizes are 4KB and the number of sectors may vary depending on the specific device. Also, for INFO memory space, only sectors <b>FLASH_SECTOR0</b> and <b>FLASH_SECTOR1</b> will exist.</dd>
<dd>
Not all devices will contain a dedicated INFO memory. Please check the device datasheet to see if your device has INFO memory available for use. For devices without INFO memory, any operation related to the INFO memory will be ignored by the hardware.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if sector protection disabled false otherwise. </dd></dl>

</div>
</div>
<a id="ga693049351805d98fd704c6c33b907c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga693049351805d98fd704c6c33b907c53">&#9670;&nbsp;</a></span>FlashCtl_unregisterInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashCtl_unregisterInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters the interrupt handler for the flash system.</p>
<p>This function unregisters the handler to be called when a clock system interrupt occurs. This function also masks off the interrupt in the interrupt controller so that the interrupt handler no longer is called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#gae2a33716d48a45c7c719304d185c6620">Interrupt_registerInterrupt()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gadfc54f0fae16bba79bd2e9d8be51dd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfc54f0fae16bba79bd2e9d8be51dd82">&#9670;&nbsp;</a></span>FlashCtl_verifyMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlashCtl_verifyMemory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>verifyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verifies a given segment of memory based off either a high (1) or low (0) state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verifyAddr</td><td>Start address where verification will begin</td></tr>
    <tr><td class="paramname">length</td><td>Length in bytes to verify based off the pattern</td></tr>
    <tr><td class="paramname">pattern</td><td>The pattern which verification will check versus. This can either be a low pattern (each register will be checked versus a pattern of 32 zeros, or a high pattern (each register will be checked versus a pattern of 32 ones). Valid values are: FLASH_0_PATTERN, FLASH_1_PATTERN</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>There are no sector/boundary restrictions for this function, however it is encouraged to proved a start address aligned on 32-bit boundaries. Providing an unaligned address will result in unaligned data accesses and detriment efficiency.</dd>
<dd>
This function is blocking and will not exit until operation has either completed or failed due to an error. Furthermore, given the complex verification requirements of the flash controller, master interrupts are disabled throughout execution of this function. The original interrupt context is saved at the start of execution and restored prior to exit of the API.</dd>
<dd>
Due to the hardware limitations of the flash controller, this function cannot verify a memory adress in the same flash bank that it is executing from. If using the ROM version of this API (by using the (ROM_ or MAP_ prefixes) this is a don't care, however if this API resides in flash then special care needs to be taken to ensure no code execution or reads happen in the flash bank being programmed while this API is being executed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if memory verification is successful, false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
