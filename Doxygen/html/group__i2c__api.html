<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vitalsgrafr UY: I2c_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vitalsgrafr UY
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2c_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structe_u_s_c_i___i2_c___master_config.html">eUSCI_I2C_MasterConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__e_u_s_c_i___i2_c___master_config.html">_eUSCI_I2C_MasterConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for <a class="el" href="struct__e_u_s_c_i___i2_c___master_config.html">_eUSCI_I2C_MasterConfig</a> structure.  <a href="struct__e_u_s_c_i___i2_c___master_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabdf54acec28bb29dba3a8154b0f5ad8d"><td class="memItemLeft" align="right" valign="top"><a id="gabdf54acec28bb29dba3a8154b0f5ad8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_NO_AUTO_STOP</b>&#160;&#160;&#160;EUSCI_B_CTLW1_ASTP_0</td></tr>
<tr class="separator:gabdf54acec28bb29dba3a8154b0f5ad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab506045a325cf4210dd3940b8338c8fa"><td class="memItemLeft" align="right" valign="top"><a id="gab506045a325cf4210dd3940b8338c8fa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_SET_BYTECOUNT_THRESHOLD_FLAG</b>&#160;&#160;&#160;EUSCI_B_CTLW1_ASTP_1</td></tr>
<tr class="separator:gab506045a325cf4210dd3940b8338c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7ba49a80392ab6d057cd719e1f814a8"><td class="memItemLeft" align="right" valign="top"><a id="gaf7ba49a80392ab6d057cd719e1f814a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_SEND_STOP_AUTOMATICALLY_ON_BYTECOUNT_THRESHOLD</b>&#160;&#160;&#160;EUSCI_B_CTLW1_ASTP_2</td></tr>
<tr class="separator:gaf7ba49a80392ab6d057cd719e1f814a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f404a45a104982db5892db15001f635"><td class="memItemLeft" align="right" valign="top"><a id="ga4f404a45a104982db5892db15001f635"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_SET_DATA_RATE_1MBPS</b>&#160;&#160;&#160;1000000</td></tr>
<tr class="separator:ga4f404a45a104982db5892db15001f635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee14dda38296d701a291f234c40b8d23"><td class="memItemLeft" align="right" valign="top"><a id="gaee14dda38296d701a291f234c40b8d23"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_SET_DATA_RATE_400KBPS</b>&#160;&#160;&#160;400000</td></tr>
<tr class="separator:gaee14dda38296d701a291f234c40b8d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga366ee169697b56b83a8576a545ca211e"><td class="memItemLeft" align="right" valign="top"><a id="ga366ee169697b56b83a8576a545ca211e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_SET_DATA_RATE_100KBPS</b>&#160;&#160;&#160;100000</td></tr>
<tr class="separator:ga366ee169697b56b83a8576a545ca211e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb3950ecf9e51c141ce9444f1789c664"><td class="memItemLeft" align="right" valign="top"><a id="gafb3950ecf9e51c141ce9444f1789c664"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_CLOCKSOURCE_ACLK</b>&#160;&#160;&#160;EUSCI_B_CTLW0_SSEL__ACLK</td></tr>
<tr class="separator:gafb3950ecf9e51c141ce9444f1789c664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf40d954a6db872235a38f1eafc9d26a2"><td class="memItemLeft" align="right" valign="top"><a id="gaf40d954a6db872235a38f1eafc9d26a2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_CLOCKSOURCE_SMCLK</b>&#160;&#160;&#160;EUSCI_B_CTLW0_SSEL__SMCLK</td></tr>
<tr class="separator:gaf40d954a6db872235a38f1eafc9d26a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga562343e5b1312ea5e75309f324768fde"><td class="memItemLeft" align="right" valign="top"><a id="ga562343e5b1312ea5e75309f324768fde"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_OWN_ADDRESS_OFFSET0</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:ga562343e5b1312ea5e75309f324768fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78462a6a4a8c40960bc96aebba3c1fd4"><td class="memItemLeft" align="right" valign="top"><a id="ga78462a6a4a8c40960bc96aebba3c1fd4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_OWN_ADDRESS_OFFSET1</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ga78462a6a4a8c40960bc96aebba3c1fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga551778581b559e263371a81e5e5db48e"><td class="memItemLeft" align="right" valign="top"><a id="ga551778581b559e263371a81e5e5db48e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_OWN_ADDRESS_OFFSET2</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:ga551778581b559e263371a81e5e5db48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb1f44201981ab2df006119f0859c8b"><td class="memItemLeft" align="right" valign="top"><a id="gaccb1f44201981ab2df006119f0859c8b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_OWN_ADDRESS_OFFSET3</b>&#160;&#160;&#160;0x06</td></tr>
<tr class="separator:gaccb1f44201981ab2df006119f0859c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7eb5e7d9dd19b975c06bdba666c2074"><td class="memItemLeft" align="right" valign="top"><a id="gae7eb5e7d9dd19b975c06bdba666c2074"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_OWN_ADDRESS_DISABLE</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gae7eb5e7d9dd19b975c06bdba666c2074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b56b55726616c0facae289cf194fa42"><td class="memItemLeft" align="right" valign="top"><a id="ga7b56b55726616c0facae289cf194fa42"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_OWN_ADDRESS_ENABLE</b>&#160;&#160;&#160;EUSCI_B_I2COA0_OAEN</td></tr>
<tr class="separator:ga7b56b55726616c0facae289cf194fa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dc1be98ae158e6260ab79676c463267"><td class="memItemLeft" align="right" valign="top"><a id="ga5dc1be98ae158e6260ab79676c463267"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_TRANSMIT_MODE</b>&#160;&#160;&#160;EUSCI_B_CTLW0_TR</td></tr>
<tr class="separator:ga5dc1be98ae158e6260ab79676c463267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f0b61dd0b736116817f523efa07ee3"><td class="memItemLeft" align="right" valign="top"><a id="gae9f0b61dd0b736116817f523efa07ee3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_RECEIVE_MODE</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gae9f0b61dd0b736116817f523efa07ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55eb35482b54acee8553ed12f91073d3"><td class="memItemLeft" align="right" valign="top"><a id="ga55eb35482b54acee8553ed12f91073d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_NAK_INTERRUPT</b>&#160;&#160;&#160;EUSCI_B_IE_NACKIE</td></tr>
<tr class="separator:ga55eb35482b54acee8553ed12f91073d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0676bfada955b746bb03e24ce3332bd7"><td class="memItemLeft" align="right" valign="top"><a id="ga0676bfada955b746bb03e24ce3332bd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT</b>&#160;&#160;&#160;EUSCI_B_IE_ALIE</td></tr>
<tr class="separator:ga0676bfada955b746bb03e24ce3332bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ba1699fb5db315ee6a1f71fe1dbae84"><td class="memItemLeft" align="right" valign="top"><a id="ga4ba1699fb5db315ee6a1f71fe1dbae84"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_STOP_INTERRUPT</b>&#160;&#160;&#160;EUSCI_B_IE_STPIE</td></tr>
<tr class="separator:ga4ba1699fb5db315ee6a1f71fe1dbae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11bd4c8e27bb97c205208773fde2bdb1"><td class="memItemLeft" align="right" valign="top"><a id="ga11bd4c8e27bb97c205208773fde2bdb1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_START_INTERRUPT</b>&#160;&#160;&#160;EUSCI_B_IE_STTIE</td></tr>
<tr class="separator:ga11bd4c8e27bb97c205208773fde2bdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb45c97dd62ef9fb5f8943c5abdeb2f7"><td class="memItemLeft" align="right" valign="top"><a id="gafb45c97dd62ef9fb5f8943c5abdeb2f7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT0</b>&#160;&#160;&#160;EUSCI_B_IE_TXIE0</td></tr>
<tr class="separator:gafb45c97dd62ef9fb5f8943c5abdeb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4970ff621f00967c1628caeec5ae2ea1"><td class="memItemLeft" align="right" valign="top"><a id="ga4970ff621f00967c1628caeec5ae2ea1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT1</b>&#160;&#160;&#160;EUSCI_B_IE_TXIE1</td></tr>
<tr class="separator:ga4970ff621f00967c1628caeec5ae2ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e094fd57627e5d461ec5474863446d"><td class="memItemLeft" align="right" valign="top"><a id="gab5e094fd57627e5d461ec5474863446d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT2</b>&#160;&#160;&#160;EUSCI_B_IE_TXIE2</td></tr>
<tr class="separator:gab5e094fd57627e5d461ec5474863446d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1104d68594d2b0bba1d6d633c584220e"><td class="memItemLeft" align="right" valign="top"><a id="ga1104d68594d2b0bba1d6d633c584220e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT3</b>&#160;&#160;&#160;EUSCI_B_IE_TXIE3</td></tr>
<tr class="separator:ga1104d68594d2b0bba1d6d633c584220e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b045d69cd029ea0bccb6a3dc296c52"><td class="memItemLeft" align="right" valign="top"><a id="gac0b045d69cd029ea0bccb6a3dc296c52"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_RECEIVE_INTERRUPT0</b>&#160;&#160;&#160;EUSCI_B_IE_RXIE0</td></tr>
<tr class="separator:gac0b045d69cd029ea0bccb6a3dc296c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab89dc0b19c2a77e13e327c3f821b715e"><td class="memItemLeft" align="right" valign="top"><a id="gab89dc0b19c2a77e13e327c3f821b715e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_RECEIVE_INTERRUPT1</b>&#160;&#160;&#160;EUSCI_B_IE_RXIE1</td></tr>
<tr class="separator:gab89dc0b19c2a77e13e327c3f821b715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6700e06ed1b6d8aec48fb50cdb8f0f2"><td class="memItemLeft" align="right" valign="top"><a id="gac6700e06ed1b6d8aec48fb50cdb8f0f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_RECEIVE_INTERRUPT2</b>&#160;&#160;&#160;EUSCI_B_IE_RXIE2</td></tr>
<tr class="separator:gac6700e06ed1b6d8aec48fb50cdb8f0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec174b16d62456d0c0cc9023053b78d"><td class="memItemLeft" align="right" valign="top"><a id="gaeec174b16d62456d0c0cc9023053b78d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_RECEIVE_INTERRUPT3</b>&#160;&#160;&#160;EUSCI_B_IE_RXIE3</td></tr>
<tr class="separator:gaeec174b16d62456d0c0cc9023053b78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0959d4da940be7ca02181fc5a1b2de59"><td class="memItemLeft" align="right" valign="top"><a id="ga0959d4da940be7ca02181fc5a1b2de59"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_BIT9_POSITION_INTERRUPT</b>&#160;&#160;&#160;EUSCI_B_IE_BIT9IE</td></tr>
<tr class="separator:ga0959d4da940be7ca02181fc5a1b2de59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1deb7c01d5c63bd12b1f767d6b7118e4"><td class="memItemLeft" align="right" valign="top"><a id="ga1deb7c01d5c63bd12b1f767d6b7118e4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT</b>&#160;&#160;&#160;EUSCI_B_IE_CLTOIE</td></tr>
<tr class="separator:ga1deb7c01d5c63bd12b1f767d6b7118e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcdf7820bfba274776656c1e4d974c3"><td class="memItemLeft" align="right" valign="top"><a id="ga7fcdf7820bfba274776656c1e4d974c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT</b>&#160;&#160;&#160;EUSCI_B_IE_BCNTIE</td></tr>
<tr class="separator:ga7fcdf7820bfba274776656c1e4d974c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b4c2775857268b0cfd63ba24b346104"><td class="memItemLeft" align="right" valign="top"><a id="ga4b4c2775857268b0cfd63ba24b346104"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_BUS_BUSY</b>&#160;&#160;&#160;EUSCI_B_STATW_BBUSY</td></tr>
<tr class="separator:ga4b4c2775857268b0cfd63ba24b346104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac69c1d347ac4e85b58b47967657c61e1"><td class="memItemLeft" align="right" valign="top"><a id="gac69c1d347ac4e85b58b47967657c61e1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_BUS_NOT_BUSY</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gac69c1d347ac4e85b58b47967657c61e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4649450b9181f5c297a923749ed665a1"><td class="memItemLeft" align="right" valign="top"><a id="ga4649450b9181f5c297a923749ed665a1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_STOP_SEND_COMPLETE</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:ga4649450b9181f5c297a923749ed665a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606099b54873acb784958bac2027eea8"><td class="memItemLeft" align="right" valign="top"><a id="ga606099b54873acb784958bac2027eea8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_SENDING_STOP</b>&#160;&#160;&#160;EUSCI_B_CTLW0_TXSTP</td></tr>
<tr class="separator:ga606099b54873acb784958bac2027eea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab357bff2d68cf070105a12a88a305a2b"><td class="memItemLeft" align="right" valign="top"><a id="gab357bff2d68cf070105a12a88a305a2b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_START_SEND_COMPLETE</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gab357bff2d68cf070105a12a88a305a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c2106563fce32a4636c79e65110e2a"><td class="memItemLeft" align="right" valign="top"><a id="ga17c2106563fce32a4636c79e65110e2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_SENDING_START</b>&#160;&#160;&#160;EUSCI_B_CTLW0_TXSTT</td></tr>
<tr class="separator:ga17c2106563fce32a4636c79e65110e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434c57368121625e4bbec7f1d939f227"><td class="memItemLeft" align="right" valign="top"><a id="ga434c57368121625e4bbec7f1d939f227"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_slaveInit</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga4ef19412f074993bb68bd879c0f15ffa">I2C_initSlave</a></td></tr>
<tr class="separator:ga434c57368121625e4bbec7f1d939f227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869b0396cf2caa9fa6ccd113306ca368"><td class="memItemLeft" align="right" valign="top"><a id="ga869b0396cf2caa9fa6ccd113306ca368"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_enable</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga1e6061909ccc69d401ed9867aa76312e">I2C_enableModule</a></td></tr>
<tr class="separator:ga869b0396cf2caa9fa6ccd113306ca368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eecf4dbd6c8c62a5cc080ba48bd9dc2"><td class="memItemLeft" align="right" valign="top"><a id="ga7eecf4dbd6c8c62a5cc080ba48bd9dc2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_disable</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga5fae639b5fb6e53879afb48ccf07fc65">I2C_disableModule</a></td></tr>
<tr class="separator:ga7eecf4dbd6c8c62a5cc080ba48bd9dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf40ba3d8df0d6479304d8f23f22fcee0"><td class="memItemLeft" align="right" valign="top"><a id="gaf40ba3d8df0d6479304d8f23f22fcee0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_setSlaveAddress</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gac81bd3dd72311c4f71ff98a4ffd5f588">I2C_setSlaveAddress</a></td></tr>
<tr class="separator:gaf40ba3d8df0d6479304d8f23f22fcee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c937c15a77cc6d8a3fed6de53ab6d25"><td class="memItemLeft" align="right" valign="top"><a id="ga8c937c15a77cc6d8a3fed6de53ab6d25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_setMode</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga9bbefbfc634dc34fa6c399144e9c10cf">I2C_setMode</a></td></tr>
<tr class="separator:ga8c937c15a77cc6d8a3fed6de53ab6d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf1c9a7c3c8cef3aa59377a6b889d9c"><td class="memItemLeft" align="right" valign="top"><a id="ga5cf1c9a7c3c8cef3aa59377a6b889d9c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_getMode</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga0cd6b21aa8d288e74c1213705759c788">I2C_getMode</a></td></tr>
<tr class="separator:ga5cf1c9a7c3c8cef3aa59377a6b889d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafafcd30108d20f03ae175a6135056dd7"><td class="memItemLeft" align="right" valign="top"><a id="gafafcd30108d20f03ae175a6135056dd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_slaveDataPut</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gad9d79d99135de484c1a5d2b2bdf8a44d">I2C_slavePutData</a></td></tr>
<tr class="separator:gafafcd30108d20f03ae175a6135056dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6027062b5131076183daf5b1f4792c16"><td class="memItemLeft" align="right" valign="top"><a id="ga6027062b5131076183daf5b1f4792c16"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_slaveDataGet</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga713e0ba43ec941d455bbf040de54b526">I2C_slaveGetData</a></td></tr>
<tr class="separator:ga6027062b5131076183daf5b1f4792c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b8f1ff36db443a720d4995ed188999"><td class="memItemLeft" align="right" valign="top"><a id="ga35b8f1ff36db443a720d4995ed188999"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_isBusBusy</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gaed5d4be0b3a6755469a82aee23f4cd86">I2C_isBusBusy</a></td></tr>
<tr class="separator:ga35b8f1ff36db443a720d4995ed188999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcdfff163deba6bd7b9d8c7d838c8d94"><td class="memItemLeft" align="right" valign="top"><a id="gadcdfff163deba6bd7b9d8c7d838c8d94"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterIsStopSent</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga1d97b00aeae71ff59e8b72fb45514af0">I2C_masterIsStopSent</a></td></tr>
<tr class="separator:gadcdfff163deba6bd7b9d8c7d838c8d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0346ee10f916147b05a8cce9af2cda62"><td class="memItemLeft" align="right" valign="top"><a id="ga0346ee10f916147b05a8cce9af2cda62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterIsStartSent</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gad1bccbb35d2a6d5b7c04c3ea74d8b14b">I2C_masterIsStartSent</a></td></tr>
<tr class="separator:ga0346ee10f916147b05a8cce9af2cda62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96da5026641a9815cdf49b4d9ce5ba79"><td class="memItemLeft" align="right" valign="top"><a id="ga96da5026641a9815cdf49b4d9ce5ba79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_enableInterrupt</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gafa37ca83de74b961dd11fcb7884fae50">I2C_enableInterrupt</a></td></tr>
<tr class="separator:ga96da5026641a9815cdf49b4d9ce5ba79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1611979a29dd5b069bc511bb0bdf0963"><td class="memItemLeft" align="right" valign="top"><a id="ga1611979a29dd5b069bc511bb0bdf0963"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_disableInterrupt</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gaf8466b8db0041ddeb6ba90e49a355c61">I2C_disableInterrupt</a></td></tr>
<tr class="separator:ga1611979a29dd5b069bc511bb0bdf0963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a829cc3c8d300f28f4284d760764269"><td class="memItemLeft" align="right" valign="top"><a id="ga2a829cc3c8d300f28f4284d760764269"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_clearInterruptFlag</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gaef0d4264f06934a6765a33da5b203192">I2C_clearInterruptFlag</a></td></tr>
<tr class="separator:ga2a829cc3c8d300f28f4284d760764269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe0bd1d9f616af11d8f6a38406c9c441"><td class="memItemLeft" align="right" valign="top"><a id="gabe0bd1d9f616af11d8f6a38406c9c441"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_getInterruptStatus</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga8a3e16e87fd72d93ebf940829d8362a4">I2C_getEnabledInterruptStatus</a></td></tr>
<tr class="separator:gabe0bd1d9f616af11d8f6a38406c9c441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabbbe6ecb99a6b55d3afcf9e3c94b42c"><td class="memItemLeft" align="right" valign="top"><a id="gaabbbe6ecb99a6b55d3afcf9e3c94b42c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterSendSingleByte</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga54418ded3676bfdc38aeb7da3a2a6617">I2C_masterSendSingleByte</a></td></tr>
<tr class="separator:gaabbbe6ecb99a6b55d3afcf9e3c94b42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga442b797a7fac185e269f79577991f643"><td class="memItemLeft" align="right" valign="top"><a id="ga442b797a7fac185e269f79577991f643"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterReceiveSingleByte</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga236f8294bb903697544fc3409d92744c">I2C_masterReceiveSingleByte</a></td></tr>
<tr class="separator:ga442b797a7fac185e269f79577991f643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7719de5dec60304742b9efa3290d3ea"><td class="memItemLeft" align="right" valign="top"><a id="gab7719de5dec60304742b9efa3290d3ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterSendSingleByteWithTimeout</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gaeec9c4fe134818b61ad979643180201a">I2C_masterSendSingleByteWithTimeout</a></td></tr>
<tr class="separator:gab7719de5dec60304742b9efa3290d3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53606fc5448fba04c8ad3f9d8a65ab07"><td class="memItemLeft" align="right" valign="top"><a id="ga53606fc5448fba04c8ad3f9d8a65ab07"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteSendStart</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gadfccc11f1d2e3520d836a66b21aed810">I2C_masterSendMultiByteStart</a></td></tr>
<tr class="separator:ga53606fc5448fba04c8ad3f9d8a65ab07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8d4d0221146494d502e30c0023bb12"><td class="memItemLeft" align="right" valign="top"><a id="ga1f8d4d0221146494d502e30c0023bb12"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteSendStartWithTimeout</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga532d1f8137bbc1f380a207c8f1e8238a">I2C_masterSendMultiByteStartWithTimeout</a></td></tr>
<tr class="separator:ga1f8d4d0221146494d502e30c0023bb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac527ce092b0f290877ba7bc623c94585"><td class="memItemLeft" align="right" valign="top"><a id="gac527ce092b0f290877ba7bc623c94585"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteSendNext</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga4053dce93a87f323604e51f8facde87e">I2C_masterSendMultiByteNext</a></td></tr>
<tr class="separator:gac527ce092b0f290877ba7bc623c94585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefac21c48bcc1c188b85e5f7b12a0c9f"><td class="memItemLeft" align="right" valign="top"><a id="gaefac21c48bcc1c188b85e5f7b12a0c9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteSendNextWithTimeout</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga5a2e020203de816f585389be3e67b1c8">I2C_masterSendMultiByteNextWithTimeout</a></td></tr>
<tr class="separator:gaefac21c48bcc1c188b85e5f7b12a0c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ba11c660c37943c2dfb430731e3c246"><td class="memItemLeft" align="right" valign="top"><a id="ga4ba11c660c37943c2dfb430731e3c246"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteSendFinish</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gabf5551e9a119610c6e5ff9cf099c5d52">I2C_masterSendMultiByteFinish</a></td></tr>
<tr class="separator:ga4ba11c660c37943c2dfb430731e3c246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae422de10ac9b8329b61a5e4802bd3c6e"><td class="memItemLeft" align="right" valign="top"><a id="gae422de10ac9b8329b61a5e4802bd3c6e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteSendFinishWithTimeout</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga07ee528beae298ed9ea2afc686d7e74a">I2C_masterSendMultiByteFinishWithTimeout</a></td></tr>
<tr class="separator:gae422de10ac9b8329b61a5e4802bd3c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3522a8e0d18cde12c7be475ea12cfd58"><td class="memItemLeft" align="right" valign="top"><a id="ga3522a8e0d18cde12c7be475ea12cfd58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterSendStart</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga50af773579d945b926b3ced3e9dc3767">I2C_masterSendStart</a></td></tr>
<tr class="separator:ga3522a8e0d18cde12c7be475ea12cfd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b77f40def07b665fc6f4ffdad9c39e"><td class="memItemLeft" align="right" valign="top"><a id="gab7b77f40def07b665fc6f4ffdad9c39e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteSendStop</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga51b1dfae8aacd384b0f29f88c36e395e">I2C_masterSendMultiByteStop</a></td></tr>
<tr class="separator:gab7b77f40def07b665fc6f4ffdad9c39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6e75d3494db1f271fd9bc7a8cc8ab4e"><td class="memItemLeft" align="right" valign="top"><a id="gaf6e75d3494db1f271fd9bc7a8cc8ab4e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteSendStopWithTimeout</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga5c6eb3a86a4fce62a64e45848b2fe8ea">I2C_masterSendMultiByteStopWithTimeout</a></td></tr>
<tr class="separator:gaf6e75d3494db1f271fd9bc7a8cc8ab4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7a310b7e5a1cc1f1ac9adb852bbb42"><td class="memItemLeft" align="right" valign="top"><a id="gaea7a310b7e5a1cc1f1ac9adb852bbb42"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterReceiveStart</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gae053bddc0f1eb08fdfb519d44863809b">I2C_masterReceiveStart</a></td></tr>
<tr class="separator:gaea7a310b7e5a1cc1f1ac9adb852bbb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc5433ba79e1c7d89ac39f79ffc65062"><td class="memItemLeft" align="right" valign="top"><a id="gabc5433ba79e1c7d89ac39f79ffc65062"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteReceiveNext</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga4eb51daa1d4dea5c9ca8b5fb4a56b10e">I2C_masterReceiveMultiByteNext</a></td></tr>
<tr class="separator:gabc5433ba79e1c7d89ac39f79ffc65062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf03bab7e33568628ae88b69b0ad35ea"><td class="memItemLeft" align="right" valign="top"><a id="gaaf03bab7e33568628ae88b69b0ad35ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteReceiveFinish</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gaec5e785bf3ba735b61fd40e4a21a8748">I2C_masterReceiveMultiByteFinish</a></td></tr>
<tr class="separator:gaaf03bab7e33568628ae88b69b0ad35ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65bcaed89ce1e323d3beaefd9d09c29"><td class="memItemLeft" align="right" valign="top"><a id="gab65bcaed89ce1e323d3beaefd9d09c29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteReceiveFinishWithTimeout</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga565a23bfa77f1c00446d3a05f6d7208f">I2C_masterReceiveMultiByteFinishWithTimeout</a></td></tr>
<tr class="separator:gab65bcaed89ce1e323d3beaefd9d09c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9de68b1d0c15ba9c0c87fb6e724e2d13"><td class="memItemLeft" align="right" valign="top"><a id="ga9de68b1d0c15ba9c0c87fb6e724e2d13"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterMultiByteReceiveStop</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga57530106a52aec22d4a478634c5557c0">I2C_masterReceiveMultiByteStop</a></td></tr>
<tr class="separator:ga9de68b1d0c15ba9c0c87fb6e724e2d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga578340ff87bcc3d86a7f17bf81e760b1"><td class="memItemLeft" align="right" valign="top"><a id="ga578340ff87bcc3d86a7f17bf81e760b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_enableMultiMasterMode</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#gacb92090eb8bea40c79cc10532f50ed85">I2C_enableMultiMasterMode</a></td></tr>
<tr class="separator:ga578340ff87bcc3d86a7f17bf81e760b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e070d6a91733b2ec3ed6a6f6f3f2f6"><td class="memItemLeft" align="right" valign="top"><a id="gac7e070d6a91733b2ec3ed6a6f6f3f2f6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_disableMultiMasterMode</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga982c05ed3226a0d56f18375c9e15a638">I2C_disableMultiMasterMode</a></td></tr>
<tr class="separator:gac7e070d6a91733b2ec3ed6a6f6f3f2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5befdd66fb97ab6e751d297b25cdd4be"><td class="memItemLeft" align="right" valign="top"><a id="ga5befdd66fb97ab6e751d297b25cdd4be"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_masterSingleReceive</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga17ce90399fdc3166057984e77100c46e">I2C_masterReceiveSingle</a></td></tr>
<tr class="separator:ga5befdd66fb97ab6e751d297b25cdd4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa160fd0d94da7a301da1e32759afb329"><td class="memItemLeft" align="right" valign="top"><a id="gaa160fd0d94da7a301da1e32759afb329"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_getReceiveBufferAddressForDMA</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga30b55341d5d42a34ba8e67527ccc1461">I2C_getReceiveBufferAddressForDMA</a></td></tr>
<tr class="separator:gaa160fd0d94da7a301da1e32759afb329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a894d17eb7149250bb1f68cdd371a49"><td class="memItemLeft" align="right" valign="top"><a id="ga5a894d17eb7149250bb1f68cdd371a49"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EUSCI_B_I2C_getTransmitBufferAddressForDMA</b>&#160;&#160;&#160;<a class="el" href="group__i2c__api.html#ga0dd622f2bc3aa289c8553c561e7af803">I2C_getTransmitBufferAddressForDMA</a></td></tr>
<tr class="separator:ga5a894d17eb7149250bb1f68cdd371a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7100abc4dd16cb56de071c29d00383b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga7100abc4dd16cb56de071c29d00383b7">I2C_initMaster</a> (uint32_t moduleInstance, const <a class="el" href="structe_u_s_c_i___i2_c___master_config.html">eUSCI_I2C_MasterConfig</a> *config)</td></tr>
<tr class="separator:ga7100abc4dd16cb56de071c29d00383b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef19412f074993bb68bd879c0f15ffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga4ef19412f074993bb68bd879c0f15ffa">I2C_initSlave</a> (uint32_t moduleInstance, uint_fast16_t slaveAddress, uint_fast8_t slaveAddressOffset, uint32_t slaveOwnAddressEnable)</td></tr>
<tr class="separator:ga4ef19412f074993bb68bd879c0f15ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6061909ccc69d401ed9867aa76312e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga1e6061909ccc69d401ed9867aa76312e">I2C_enableModule</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga1e6061909ccc69d401ed9867aa76312e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fae639b5fb6e53879afb48ccf07fc65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga5fae639b5fb6e53879afb48ccf07fc65">I2C_disableModule</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga5fae639b5fb6e53879afb48ccf07fc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81bd3dd72311c4f71ff98a4ffd5f588"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gac81bd3dd72311c4f71ff98a4ffd5f588">I2C_setSlaveAddress</a> (uint32_t moduleInstance, uint_fast16_t slaveAddress)</td></tr>
<tr class="separator:gac81bd3dd72311c4f71ff98a4ffd5f588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bbefbfc634dc34fa6c399144e9c10cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga9bbefbfc634dc34fa6c399144e9c10cf">I2C_setMode</a> (uint32_t moduleInstance, uint_fast8_t mode)</td></tr>
<tr class="separator:ga9bbefbfc634dc34fa6c399144e9c10cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd6b21aa8d288e74c1213705759c788"><td class="memItemLeft" align="right" valign="top">uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga0cd6b21aa8d288e74c1213705759c788">I2C_getMode</a> (uint32_t moduleInstance)</td></tr>
<tr class="memdesc:ga0cd6b21aa8d288e74c1213705759c788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mode of the I2C device.  <a href="group__i2c__api.html#ga0cd6b21aa8d288e74c1213705759c788">More...</a><br /></td></tr>
<tr class="separator:ga0cd6b21aa8d288e74c1213705759c788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9d79d99135de484c1a5d2b2bdf8a44d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gad9d79d99135de484c1a5d2b2bdf8a44d">I2C_slavePutData</a> (uint32_t moduleInstance, uint8_t transmitData)</td></tr>
<tr class="separator:gad9d79d99135de484c1a5d2b2bdf8a44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713e0ba43ec941d455bbf040de54b526"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga713e0ba43ec941d455bbf040de54b526">I2C_slaveGetData</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga713e0ba43ec941d455bbf040de54b526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5d4be0b3a6755469a82aee23f4cd86"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaed5d4be0b3a6755469a82aee23f4cd86">I2C_isBusBusy</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:gaed5d4be0b3a6755469a82aee23f4cd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54418ded3676bfdc38aeb7da3a2a6617"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga54418ded3676bfdc38aeb7da3a2a6617">I2C_masterSendSingleByte</a> (uint32_t moduleInstance, uint8_t txData)</td></tr>
<tr class="separator:ga54418ded3676bfdc38aeb7da3a2a6617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec9c4fe134818b61ad979643180201a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaeec9c4fe134818b61ad979643180201a">I2C_masterSendSingleByteWithTimeout</a> (uint32_t moduleInstance, uint8_t txData, uint32_t timeout)</td></tr>
<tr class="separator:gaeec9c4fe134818b61ad979643180201a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfccc11f1d2e3520d836a66b21aed810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gadfccc11f1d2e3520d836a66b21aed810">I2C_masterSendMultiByteStart</a> (uint32_t moduleInstance, uint8_t txData)</td></tr>
<tr class="separator:gadfccc11f1d2e3520d836a66b21aed810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga532d1f8137bbc1f380a207c8f1e8238a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga532d1f8137bbc1f380a207c8f1e8238a">I2C_masterSendMultiByteStartWithTimeout</a> (uint32_t moduleInstance, uint8_t txData, uint32_t timeout)</td></tr>
<tr class="separator:ga532d1f8137bbc1f380a207c8f1e8238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4053dce93a87f323604e51f8facde87e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga4053dce93a87f323604e51f8facde87e">I2C_masterSendMultiByteNext</a> (uint32_t moduleInstance, uint8_t txData)</td></tr>
<tr class="separator:ga4053dce93a87f323604e51f8facde87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a2e020203de816f585389be3e67b1c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga5a2e020203de816f585389be3e67b1c8">I2C_masterSendMultiByteNextWithTimeout</a> (uint32_t moduleInstance, uint8_t txData, uint32_t timeout)</td></tr>
<tr class="separator:ga5a2e020203de816f585389be3e67b1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5551e9a119610c6e5ff9cf099c5d52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gabf5551e9a119610c6e5ff9cf099c5d52">I2C_masterSendMultiByteFinish</a> (uint32_t moduleInstance, uint8_t txData)</td></tr>
<tr class="separator:gabf5551e9a119610c6e5ff9cf099c5d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ee528beae298ed9ea2afc686d7e74a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga07ee528beae298ed9ea2afc686d7e74a">I2C_masterSendMultiByteFinishWithTimeout</a> (uint32_t moduleInstance, uint8_t txData, uint32_t timeout)</td></tr>
<tr class="separator:ga07ee528beae298ed9ea2afc686d7e74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b1dfae8aacd384b0f29f88c36e395e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga51b1dfae8aacd384b0f29f88c36e395e">I2C_masterSendMultiByteStop</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga51b1dfae8aacd384b0f29f88c36e395e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c6eb3a86a4fce62a64e45848b2fe8ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga5c6eb3a86a4fce62a64e45848b2fe8ea">I2C_masterSendMultiByteStopWithTimeout</a> (uint32_t moduleInstance, uint32_t timeout)</td></tr>
<tr class="separator:ga5c6eb3a86a4fce62a64e45848b2fe8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae053bddc0f1eb08fdfb519d44863809b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gae053bddc0f1eb08fdfb519d44863809b">I2C_masterReceiveStart</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:gae053bddc0f1eb08fdfb519d44863809b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb51daa1d4dea5c9ca8b5fb4a56b10e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga4eb51daa1d4dea5c9ca8b5fb4a56b10e">I2C_masterReceiveMultiByteNext</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga4eb51daa1d4dea5c9ca8b5fb4a56b10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5e785bf3ba735b61fd40e4a21a8748"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaec5e785bf3ba735b61fd40e4a21a8748">I2C_masterReceiveMultiByteFinish</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:gaec5e785bf3ba735b61fd40e4a21a8748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga565a23bfa77f1c00446d3a05f6d7208f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga565a23bfa77f1c00446d3a05f6d7208f">I2C_masterReceiveMultiByteFinishWithTimeout</a> (uint32_t moduleInstance, uint8_t *txData, uint32_t timeout)</td></tr>
<tr class="separator:ga565a23bfa77f1c00446d3a05f6d7208f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57530106a52aec22d4a478634c5557c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga57530106a52aec22d4a478634c5557c0">I2C_masterReceiveMultiByteStop</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga57530106a52aec22d4a478634c5557c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236f8294bb903697544fc3409d92744c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga236f8294bb903697544fc3409d92744c">I2C_masterReceiveSingleByte</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga236f8294bb903697544fc3409d92744c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ce90399fdc3166057984e77100c46e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga17ce90399fdc3166057984e77100c46e">I2C_masterReceiveSingle</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga17ce90399fdc3166057984e77100c46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30b55341d5d42a34ba8e67527ccc1461"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga30b55341d5d42a34ba8e67527ccc1461">I2C_getReceiveBufferAddressForDMA</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga30b55341d5d42a34ba8e67527ccc1461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dd622f2bc3aa289c8553c561e7af803"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga0dd622f2bc3aa289c8553c561e7af803">I2C_getTransmitBufferAddressForDMA</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga0dd622f2bc3aa289c8553c561e7af803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d97b00aeae71ff59e8b72fb45514af0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga1d97b00aeae71ff59e8b72fb45514af0">I2C_masterIsStopSent</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga1d97b00aeae71ff59e8b72fb45514af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1bccbb35d2a6d5b7c04c3ea74d8b14b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gad1bccbb35d2a6d5b7c04c3ea74d8b14b">I2C_masterIsStartSent</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:gad1bccbb35d2a6d5b7c04c3ea74d8b14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50af773579d945b926b3ced3e9dc3767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga50af773579d945b926b3ced3e9dc3767">I2C_masterSendStart</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga50af773579d945b926b3ced3e9dc3767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb92090eb8bea40c79cc10532f50ed85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gacb92090eb8bea40c79cc10532f50ed85">I2C_enableMultiMasterMode</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:gacb92090eb8bea40c79cc10532f50ed85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982c05ed3226a0d56f18375c9e15a638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga982c05ed3226a0d56f18375c9e15a638">I2C_disableMultiMasterMode</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga982c05ed3226a0d56f18375c9e15a638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa37ca83de74b961dd11fcb7884fae50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gafa37ca83de74b961dd11fcb7884fae50">I2C_enableInterrupt</a> (uint32_t moduleInstance, uint_fast16_t mask)</td></tr>
<tr class="separator:gafa37ca83de74b961dd11fcb7884fae50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8466b8db0041ddeb6ba90e49a355c61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaf8466b8db0041ddeb6ba90e49a355c61">I2C_disableInterrupt</a> (uint32_t moduleInstance, uint_fast16_t mask)</td></tr>
<tr class="separator:gaf8466b8db0041ddeb6ba90e49a355c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0d4264f06934a6765a33da5b203192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaef0d4264f06934a6765a33da5b203192">I2C_clearInterruptFlag</a> (uint32_t moduleInstance, uint_fast16_t mask)</td></tr>
<tr class="separator:gaef0d4264f06934a6765a33da5b203192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa791b93336aaa430e023d7f28e996266"><td class="memItemLeft" align="right" valign="top">uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaa791b93336aaa430e023d7f28e996266">I2C_getInterruptStatus</a> (uint32_t moduleInstance, uint16_t mask)</td></tr>
<tr class="separator:gaa791b93336aaa430e023d7f28e996266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a3e16e87fd72d93ebf940829d8362a4"><td class="memItemLeft" align="right" valign="top">uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga8a3e16e87fd72d93ebf940829d8362a4">I2C_getEnabledInterruptStatus</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga8a3e16e87fd72d93ebf940829d8362a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11f7ee27e01c7d146f329c152a325d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga11f7ee27e01c7d146f329c152a325d91">I2C_registerInterrupt</a> (uint32_t moduleInstance, void(*intHandler)(void))</td></tr>
<tr class="separator:ga11f7ee27e01c7d146f329c152a325d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ad6c37df831535294fb7c69c3f8c5ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga7ad6c37df831535294fb7c69c3f8c5ef">I2C_unregisterInterrupt</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga7ad6c37df831535294fb7c69c3f8c5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9692f848ce99e391aef5ba0310fb478b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga9692f848ce99e391aef5ba0310fb478b">I2C_slaveSendNAK</a> (uint32_t moduleInstance)</td></tr>
<tr class="separator:ga9692f848ce99e391aef5ba0310fb478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaef0d4264f06934a6765a33da5b203192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef0d4264f06934a6765a33da5b203192">&#9670;&nbsp;</a></span>I2C_clearInterruptFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_clearInterruptFlag </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears I2C interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">mask</td><td>is a bit mask of the interrupt sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>The I2C interrupt source is cleared, so that it no longer asserts. The highest interrupt flag is automatically cleared when an interrupt vector generator is used.</p>
<p>The mask parameter has the same definition as the mask parameter to <a class="el" href="group__i2c__api.html#gafa37ca83de74b961dd11fcb7884fae50">I2C_enableInterrupt()</a>.</p>
<p>Modified register is <b>UCBxIFG</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaf8466b8db0041ddeb6ba90e49a355c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8466b8db0041ddeb6ba90e49a355c61">&#9670;&nbsp;</a></span>I2C_disableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables individual I2C interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">mask</td><td>is the bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>Disables the indicated I2C interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<p>The mask parameter is the logical OR of any of the following:</p>
<ul>
<li><b>EUSCI_B_I2C_STOP_INTERRUPT</b> - STOP condition interrupt</li>
<li><b>EUSCI_B_I2C_START_INTERRUPT</b> - START condition interrupt</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT0</b> - Transmit interrupt0</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT1</b> - Transmit interrupt1</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT2</b> - Transmit interrupt2</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT3</b> - Transmit interrupt3</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT0</b> - Receive interrupt0</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT1</b> - Receive interrupt1</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT2</b> - Receive interrupt2</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT3</b> - Receive interrupt3</li>
<li><b>EUSCI_B_I2C_NAK_INTERRUPT</b> - Not-acknowledge interrupt</li>
<li><b>EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT</b> - Arbitration lost interrupt</li>
<li><b>EUSCI_B_I2C_BIT9_POSITION_INTERRUPT</b> - Bit position 9 interrupt enable</li>
<li><b>EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT</b> - Clock low timeout interrupt enable</li>
<li><b>EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT</b> - Byte counter interrupt enable</li>
</ul>
<p>Modified register is <b>UCBxIE</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga5fae639b5fb6e53879afb48ccf07fc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fae639b5fb6e53879afb48ccf07fc65">&#9670;&nbsp;</a></span>I2C_disableModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_disableModule </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the I2C block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This will disable operation of the I2C block. Modified bits are <b>UCSWRST</b> of <b>UCBxCTL1</b> register.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga982c05ed3226a0d56f18375c9e15a638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga982c05ed3226a0d56f18375c9e15a638">&#9670;&nbsp;</a></span>I2C_disableMultiMasterMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_disableMultiMasterMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables Multi Master Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>At the end of this function, the I2C module is still disabled till I2C_enableModule is invoked</p>
<p>Modified bits are <b>UCSWRST</b> of <b>OFS_UCBxCTLW0</b>, <b>UCMM</b> bit of <b>UCBxCTLW0</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gafa37ca83de74b961dd11fcb7884fae50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa37ca83de74b961dd11fcb7884fae50">&#9670;&nbsp;</a></span>I2C_enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables individual I2C interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">mask</td><td>is the bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>Enables the indicated I2C interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<p>The mask parameter is the logical OR of any of the following:</p>
<ul>
<li><b>EUSCI_B_I2C_STOP_INTERRUPT</b> - STOP condition interrupt</li>
<li><b>EUSCI_B_I2C_START_INTERRUPT</b> - START condition interrupt</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT0</b> - Transmit interrupt0</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT1</b> - Transmit interrupt1</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT2</b> - Transmit interrupt2</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT3</b> - Transmit interrupt3</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT0</b> - Receive interrupt0</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT1</b> - Receive interrupt1</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT2</b> - Receive interrupt2</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT3</b> - Receive interrupt3</li>
<li><b>EUSCI_B_I2C_NAK_INTERRUPT</b> - Not-acknowledge interrupt</li>
<li><b>EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT</b> - Arbitration lost interrupt</li>
<li><b>EUSCI_B_I2C_BIT9_POSITION_INTERRUPT</b> - Bit position 9 interrupt enable</li>
<li><b>EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT</b> - Clock low timeout interrupt enable</li>
<li><b>EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT</b> - Byte counter interrupt enable</li>
</ul>
<p>Modified registers are UCBxIFG and OFS_UCBxIE.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga1e6061909ccc69d401ed9867aa76312e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6061909ccc69d401ed9867aa76312e">&#9670;&nbsp;</a></span>I2C_enableModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_enableModule </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the I2C block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This will enable operation of the I2C block. Modified bits are <b>UCSWRST</b> of <b>UCBxCTL1</b> register.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gacb92090eb8bea40c79cc10532f50ed85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb92090eb8bea40c79cc10532f50ed85">&#9670;&nbsp;</a></span>I2C_enableMultiMasterMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_enableMultiMasterMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables Multi Master Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>At the end of this function, the I2C module is still disabled till I2C_enableModule is invoked</p>
<p>Modified bits are <b>UCSWRST</b> of <b>OFS_UCBxCTLW0</b>, <b>UCMM</b> bit of <b>UCBxCTLW0</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga8a3e16e87fd72d93ebf940829d8362a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a3e16e87fd72d93ebf940829d8362a4">&#9670;&nbsp;</a></span>I2C_getEnabledInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast16_t I2C_getEnabledInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current I2C interrupt status masked with the enabled interrupts. This function is useful to call in ISRs to get a list of pending interrupts that are actually enabled and could have caused the ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the masked status of the interrupt flag<ul>
<li><b>EUSCI_B_I2C_STOP_INTERRUPT</b> - STOP condition interrupt</li>
<li><b>EUSCI_B_I2C_START_INTERRUPT</b> - START condition interrupt</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT0</b> - Transmit interrupt0</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT1</b> - Transmit interrupt1</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT2</b> - Transmit interrupt2</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT3</b> - Transmit interrupt3</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT0</b> - Receive interrupt0</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT1</b> - Receive interrupt1</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT2</b> - Receive interrupt2</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT3</b> - Receive interrupt3</li>
<li><b>EUSCI_B_I2C_NAK_INTERRUPT</b> - Not-acknowledge interrupt</li>
<li><b>EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT</b> - Arbitration lost interrupt</li>
<li><b>EUSCI_B_I2C_BIT9_POSITION_INTERRUPT</b> - Bit position 9 interrupt enable</li>
<li><b>EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT</b> - Clock low timeout interrupt enable</li>
<li><b>EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT</b> - Byte counter interrupt enable </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa791b93336aaa430e023d7f28e996266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa791b93336aaa430e023d7f28e996266">&#9670;&nbsp;</a></span>I2C_getInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast16_t I2C_getInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current I2C interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode. </li>
</ul>
</td></tr>
    <tr><td class="paramname">mask</td><td>is the masked interrupt flag status to be returned. Mask value is the logical OR of any of the following:<ul>
<li><b>EUSCI_B_I2C_NAK_INTERRUPT</b> - Not-acknowledge interrupt</li>
<li><b>EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT</b> - Arbitration lost interrupt</li>
<li><b>EUSCI_B_I2C_STOP_INTERRUPT</b> - STOP condition interrupt</li>
<li><b>EUSCI_B_I2C_START_INTERRUPT</b> - START condition interrupt</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT0</b> - Transmit interrupt0</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT1</b> - Transmit interrupt1</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT2</b> - Transmit interrupt2</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT3</b> - Transmit interrupt3</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT0</b> - Receive interrupt0</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT1</b> - Receive interrupt1</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT2</b> - Receive interrupt2</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT3</b> - Receive interrupt3</li>
<li><b>EUSCI_B_I2C_BIT9_POSITION_INTERRUPT</b> - Bit position 9 interrupt</li>
<li><b>EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT</b> - Clock low timeout interrupt enable</li>
<li><b>EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT</b> - Byte counter interrupt enable</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the masked status of the interrupt flag<ul>
<li><b>EUSCI_B_I2C_STOP_INTERRUPT</b> - STOP condition interrupt</li>
<li><b>EUSCI_B_I2C_START_INTERRUPT</b> - START condition interrupt</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT0</b> - Transmit interrupt0</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT1</b> - Transmit interrupt1</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT2</b> - Transmit interrupt2</li>
<li><b>EUSCI_B_I2C_TRANSMIT_INTERRUPT3</b> - Transmit interrupt3</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT0</b> - Receive interrupt0</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT1</b> - Receive interrupt1</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT2</b> - Receive interrupt2</li>
<li><b>EUSCI_B_I2C_RECEIVE_INTERRUPT3</b> - Receive interrupt3</li>
<li><b>EUSCI_B_I2C_NAK_INTERRUPT</b> - Not-acknowledge interrupt</li>
<li><b>EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT</b> - Arbitration lost interrupt</li>
<li><b>EUSCI_B_I2C_BIT9_POSITION_INTERRUPT</b> - Bit position 9 interrupt enable</li>
<li><b>EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT</b> - Clock low timeout interrupt enable</li>
<li><b>EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT</b> - Byte counter interrupt enable </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0cd6b21aa8d288e74c1213705759c788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cd6b21aa8d288e74c1213705759c788">&#9670;&nbsp;</a></span>I2C_getMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast8_t I2C_getMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mode of the I2C device. </p>
<p>Current I2C transmit/receive mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Modified bits are <b>UCTR</b> of <b>UCBxCTL1</b> register.</p>
<dl class="section return"><dt>Returns</dt><dd>None Return one of the following:<ul>
<li><b>EUSCI_B_I2C_TRANSMIT_MODE</b> </li>
<li><b>EUSCI_B_I2C_RECEIVE_MODE</b> <br  />
 indicating the current mode </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga30b55341d5d42a34ba8e67527ccc1461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30b55341d5d42a34ba8e67527ccc1461">&#9670;&nbsp;</a></span>I2C_getReceiveBufferAddressForDMA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2C_getReceiveBufferAddressForDMA </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the RX Buffer of the I2C for the DMA module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the address of the I2C RX Buffer. This can be used in conjunction with the DMA to store the received data directly to memory.</p>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a id="ga0dd622f2bc3aa289c8553c561e7af803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dd622f2bc3aa289c8553c561e7af803">&#9670;&nbsp;</a></span>I2C_getTransmitBufferAddressForDMA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2C_getTransmitBufferAddressForDMA </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the TX Buffer of the I2C for the DMA module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the address of the I2C TX Buffer. This can be used in conjunction with the DMA to obtain transmitted data directly from memory.</p>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a id="ga7100abc4dd16cb56de071c29d00383b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7100abc4dd16cb56de071c29d00383b7">&#9670;&nbsp;</a></span>I2C_initMaster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_initMaster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structe_u_s_c_i___i2_c___master_config.html">eUSCI_I2C_MasterConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the I2C Master block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode. </li>
</ul>
</td></tr>
    <tr><td class="paramname">config</td><td>Configuration structure for I2C master mode</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <b>Configuration options for <a class="el" href="structe_u_s_c_i___i2_c___master_config.html">eUSCI_I2C_MasterConfig</a> structure.</b> </p><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selectClockSource</td><td>is the clock source. Valid values are<ul>
<li><b>EUSCI_B_I2C_CLOCKSOURCE_ACLK</b> </li>
<li><b>EUSCI_B_I2C_CLOCKSOURCE_SMCLK</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">i2cClk</td><td>is the rate of the clock supplied to the I2C module (the frequency in Hz of the clock source specified in selectClockSource). </td></tr>
    <tr><td class="paramname">dataRate</td><td>set up for selecting data transfer rate. Valid values are<ul>
<li><b>EUSCI_B_I2C_SET_DATA_RATE_1MBPS</b> </li>
<li><b>EUSCI_B_I2C_SET_DATA_RATE_400KBPS</b> </li>
<li><b>EUSCI_B_I2C_SET_DATA_RATE_100KBPS</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">byteCounterThreshold</td><td>sets threshold for automatic STOP or UCSTPIFG </td></tr>
    <tr><td class="paramname">autoSTOPGeneration</td><td>sets up the STOP condition generation. Valid values are<ul>
<li><b>EUSCI_B_I2C_NO_AUTO_STOP</b> </li>
<li><b>EUSCI_B_I2C_SET_BYTECOUNT_THRESHOLD_FLAG</b> </li>
<li><b>EUSCI_B_I2C_SEND_STOP_AUTOMATICALLY_ON_BYTECOUNT_THRESHOLD</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes operation of the I2C Master block. Upon successful initialization of the I2C block, this function will have set the bus speed for the master; however I2C module is still disabled till I2C_enableModule is invoked</p>
<p>Modified bits are <b>UCMST</b>,UCMODE_3,<b>UCSYNC</b> of <b>UCBxCTL0</b> register <b>UCSSELx</b>, <b>UCSWRST</b>, of <b>UCBxCTL1</b> register <b>UCBxBR0</b> and <b>UCBxBR1</b> registers </p><dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga4ef19412f074993bb68bd879c0f15ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ef19412f074993bb68bd879c0f15ffa">&#9670;&nbsp;</a></span>I2C_initSlave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_initSlave </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>slaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>slaveAddressOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slaveOwnAddressEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the I2C Slave block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">slaveAddress</td><td>7-bit or 10-bit slave address </td></tr>
    <tr><td class="paramname">slaveAddressOffset</td><td>Own address Offset referred to- 'x' value of UCBxI2COAx. Valid values are:<ul>
<li><b>EUSCI_B_I2C_OWN_ADDRESS_OFFSET0</b>,</li>
<li><b>EUSCI_B_I2C_OWN_ADDRESS_OFFSET1</b>,</li>
<li><b>EUSCI_B_I2C_OWN_ADDRESS_OFFSET2</b>,</li>
<li><b>EUSCI_B_I2C_OWN_ADDRESS_OFFSET3</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">slaveOwnAddressEnable</td><td>selects if the specified address is enabled or disabled. Valid values are:<ul>
<li><b>EUSCI_B_I2C_OWN_ADDRESS_DISABLE</b>,</li>
<li><b>EUSCI_B_I2C_OWN_ADDRESS_ENABLE</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes operation of the I2C as a Slave mode. Upon successful initialization of the I2C blocks, this function will have set the slave address but the I2C module is still disabled till I2C_enableModule is invoked.</p>
<p>The parameter slaveAddress is the value that will be compared against the slave address sent by an I2C master.</p>
<p>Modified bits are <b>UCMODE_3</b>, <b>UCSYNC</b> of <b>UCBxCTL0</b> register <b>UCSWRST</b> of <b>UCBxCTL1</b> register <b>UCBxI2COA</b> register</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaed5d4be0b3a6755469a82aee23f4cd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed5d4be0b3a6755469a82aee23f4cd86">&#9670;&nbsp;</a></span>I2C_isBusBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2C_isBusBusy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether or not the I2C bus is busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns an indication of whether or not the I2C bus is busy.This function checks the status of the bus via UCBBUSY bit in UCBxSTAT register.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns EUSCI_B_I2C_BUS_BUSY if the I2C Master is busy; otherwise, returns EUSCI_B_I2C_BUS_NOT_BUSY. </dd></dl>

</div>
</div>
<a id="gad1bccbb35d2a6d5b7c04c3ea74d8b14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1bccbb35d2a6d5b7c04c3ea74d8b14b">&#9670;&nbsp;</a></span>I2C_masterIsStartSent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C_masterIsStartSent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether Start got sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns an indication of whether or not Start got sent This function checks the status of the bus via UCTXSTT bit in UCBxCTL1 register.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the START has been sent, false if it is sending </dd></dl>

</div>
</div>
<a id="ga1d97b00aeae71ff59e8b72fb45514af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d97b00aeae71ff59e8b72fb45514af0">&#9670;&nbsp;</a></span>I2C_masterIsStopSent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2C_masterIsStopSent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether STOP got sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns an indication of whether or not STOP got sent This function checks the status of the bus via UCTXSTP bit in UCBxCTL1 register.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns EUSCI_B_I2C_STOP_SEND_COMPLETE if the I2C Master finished sending STOP; otherwise, returns EUSCI_B_I2C_SENDING_STOP. </dd></dl>

</div>
</div>
<a id="gaec5e785bf3ba735b61fd40e4a21a8748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec5e785bf3ba735b61fd40e4a21a8748">&#9670;&nbsp;</a></span>I2C_masterReceiveMultiByteFinish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2C_masterReceiveMultiByteFinish </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finishes multi-byte reception at the Master end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to initiate completion of a multi-byte reception This function</p><ul>
<li>Receives the current byte and initiates the STOP from Master to Slave</li>
</ul>
<p>Modified bits are <b>UCTXSTP</b> bit of <b>UCBxCTL1</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>Received byte at Master end. </dd></dl>

</div>
</div>
<a id="ga565a23bfa77f1c00446d3a05f6d7208f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga565a23bfa77f1c00446d3a05f6d7208f">&#9670;&nbsp;</a></span>I2C_masterReceiveMultiByteFinishWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C_masterReceiveMultiByteFinishWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>txData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finishes multi-byte reception at the Master end with timeout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">txData</td><td>is a pointer to the location to store the received byte at master end </td></tr>
    <tr><td class="paramname">timeout</td><td>is the amount of time to wait until giving up</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to initiate completion of a multi-byte reception This function</p><ul>
<li>Receives the current byte and initiates the STOP from Master to Slave</li>
</ul>
<p>Modified bits are <b>UCTXSTP</b> bit of <b>UCBxCTL1</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>0x01 or 0x00URE of the transmission process. </dd></dl>

</div>
</div>
<a id="ga4eb51daa1d4dea5c9ca8b5fb4a56b10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eb51daa1d4dea5c9ca8b5fb4a56b10e">&#9670;&nbsp;</a></span>I2C_masterReceiveMultiByteNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2C_masterReceiveMultiByteNext </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts multi-byte reception at the Master end one byte at a time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to receive each byte of a multi-byte reception This function reads currently received byte</p>
<p>Modified register is <b>UCBxRXBUF</b>. </p><dl class="section return"><dt>Returns</dt><dd>Received byte at Master end. </dd></dl>

</div>
</div>
<a id="ga57530106a52aec22d4a478634c5557c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57530106a52aec22d4a478634c5557c0">&#9670;&nbsp;</a></span>I2C_masterReceiveMultiByteStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_masterReceiveMultiByteStop </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends the STOP at the end of a multi-byte reception at the Master end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to initiate STOP</p>
<p>Modified bits are UCTXSTP bit of UCBxCTL1.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga17ce90399fdc3166057984e77100c46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17ce90399fdc3166057984e77100c46e">&#9670;&nbsp;</a></span>I2C_masterReceiveSingle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2C_masterReceiveSingle </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receives a byte that has been sent to the I2C Master Module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads a byte of data from the I2C receive data Register.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte received from by the I2C module, cast as an uint8_t. </dd></dl>

</div>
</div>
<a id="ga236f8294bb903697544fc3409d92744c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga236f8294bb903697544fc3409d92744c">&#9670;&nbsp;</a></span>I2C_masterReceiveSingleByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2C_masterReceiveSingleByte </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does single byte reception from the slave</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to receive a single byte. This function:</p><ul>
<li>Sends START and STOP</li>
<li>Waits for data reception</li>
<li>Receives one byte from the Slave</li>
</ul>
<p>Modified registers are <b>UCBxIE</b>, <b>UCBxCTL1</b>, <b>UCBxIFG</b>, <b>UCBxTXBUF</b>, <b>UCBxIE</b> </p>
<dl class="section return"><dt>Returns</dt><dd>The byte that has been received from the slave </dd></dl>

</div>
</div>
<a id="gae053bddc0f1eb08fdfb519d44863809b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae053bddc0f1eb08fdfb519d44863809b">&#9670;&nbsp;</a></span>I2C_masterReceiveStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_masterReceiveStart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts reception at the Master end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module initiate reception of a single byte. This function</p><ul>
<li>Sends START</li>
</ul>
<p>Modified bits are <b>UCTXSTT</b> bit of <b>UCBxCTL1</b>. </p><dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gabf5551e9a119610c6e5ff9cf099c5d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf5551e9a119610c6e5ff9cf099c5d52">&#9670;&nbsp;</a></span>I2C_masterSendMultiByteFinish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_masterSendMultiByteFinish </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>txData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finishes multi-byte transmission from Master to Slave</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">txData</td><td>is the last data byte to be transmitted in a multi-byte transmsission</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to send the last byte and STOP. This function</p><ul>
<li>Transmits the last data byte of a multi-byte transmission to the Slave</li>
<li>Sends STOP</li>
</ul>
<p>Modified registers are <b>UCBxTXBUF</b> and <b>UCBxCTL1</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga07ee528beae298ed9ea2afc686d7e74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07ee528beae298ed9ea2afc686d7e74a">&#9670;&nbsp;</a></span>I2C_masterSendMultiByteFinishWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C_masterSendMultiByteFinishWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>txData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finishes multi-byte transmission from Master to Slave with timeout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">txData</td><td>is the last data byte to be transmitted in a multi-byte transmission </td></tr>
    <tr><td class="paramname">timeout</td><td>is the amount of time to wait until giving up</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to send the last byte and STOP. This function</p><ul>
<li>Transmits the last data byte of a multi-byte transmission to the Slave</li>
<li>Sends STOP</li>
</ul>
<p>Modified registers are <b>UCBxTXBUF</b> and <b>UCBxCTL1</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>0x01 or 0x00URE of the transmission process. </dd></dl>

</div>
</div>
<a id="ga4053dce93a87f323604e51f8facde87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4053dce93a87f323604e51f8facde87e">&#9670;&nbsp;</a></span>I2C_masterSendMultiByteNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_masterSendMultiByteNext </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>txData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Continues multi-byte transmission from Master to Slave</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">txData</td><td>is the next data byte to be transmitted</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module continue each byte of a multi-byte trasmission. This function</p><ul>
<li>Transmits each data byte of a multi-byte transmission to the Slave</li>
</ul>
<p>Modified registers are <b>UCBxTXBUF</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga5a2e020203de816f585389be3e67b1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a2e020203de816f585389be3e67b1c8">&#9670;&nbsp;</a></span>I2C_masterSendMultiByteNextWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C_masterSendMultiByteNextWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>txData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Continues multi-byte transmission from Master to Slave with timeout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">txData</td><td>is the next data byte to be transmitted</td></tr>
    <tr><td class="paramname">timeout</td><td>is the amount of time to wait until giving up</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module continue each byte of a multi-byte transmission. This function</p><ul>
<li>Transmits each data byte of a multi-byte transmission to the Slave</li>
</ul>
<p>Modified registers are <b>UCBxTXBUF</b> </p>
<dl class="section return"><dt>Returns</dt><dd>0x01 or 0x00URE of the transmission process. </dd></dl>

</div>
</div>
<a id="gadfccc11f1d2e3520d836a66b21aed810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfccc11f1d2e3520d836a66b21aed810">&#9670;&nbsp;</a></span>I2C_masterSendMultiByteStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_masterSendMultiByteStart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>txData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts multi-byte transmission from Master to Slave</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">txData</td><td>is the first data byte to be transmitted</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to send a single byte. This function</p><ul>
<li>Sends START</li>
<li>Transmits the first data byte of a multi-byte transmission to the Slave</li>
</ul>
<p>Modified registers are <b>UCBxIE</b>, <b>UCBxCTL1</b>, <b>UCBxIFG</b>, <b>UCBxTXBUF</b>, <b>UCBxIE</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga532d1f8137bbc1f380a207c8f1e8238a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga532d1f8137bbc1f380a207c8f1e8238a">&#9670;&nbsp;</a></span>I2C_masterSendMultiByteStartWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C_masterSendMultiByteStartWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>txData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts multi-byte transmission from Master to Slave with timeout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">txData</td><td>is the first data byte to be transmitted </td></tr>
    <tr><td class="paramname">timeout</td><td>is the amount of time to wait until giving up</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to send a single byte. This function</p><ul>
<li>Sends START</li>
<li>Transmits the first data byte of a multi-byte transmission to the Slave</li>
</ul>
<p>Modified registers are <b>UCBxIE</b>, <b>UCBxCTL1</b>, <b>UCBxIFG</b>, <b>UCBxTXBUF</b>, <b>UCBxIE</b> </p>
<dl class="section return"><dt>Returns</dt><dd>0x01 or 0x00URE of the transmission process. </dd></dl>

</div>
</div>
<a id="ga51b1dfae8aacd384b0f29f88c36e395e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51b1dfae8aacd384b0f29f88c36e395e">&#9670;&nbsp;</a></span>I2C_masterSendMultiByteStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_masterSendMultiByteStop </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send STOP byte at the end of a multi-byte transmission from Master to Slave</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module send STOP at the end of a multi-byte transmission</p>
<p>This function</p><ul>
<li>Send a STOP after current transmission is complete</li>
</ul>
<p>Modified bits are <b>UCTXSTP</b> bit of <b>UCBxCTL1</b>. </p><dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga5c6eb3a86a4fce62a64e45848b2fe8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c6eb3a86a4fce62a64e45848b2fe8ea">&#9670;&nbsp;</a></span>I2C_masterSendMultiByteStopWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C_masterSendMultiByteStopWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send STOP byte at the end of a multi-byte transmission from Master to Slave with timeout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">timeout</td><td>is the amount of time to wait until giving up</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module send STOP at the end of a multi-byte transmission</p>
<p>This function</p><ul>
<li>Send a STOP after current transmission is complete</li>
</ul>
<p>Modified bits are <b>UCTXSTP</b> bit of <b>UCBxCTL1</b>. </p><dl class="section return"><dt>Returns</dt><dd>0x01 or 0x00URE of the transmission process. </dd></dl>

</div>
</div>
<a id="ga54418ded3676bfdc38aeb7da3a2a6617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54418ded3676bfdc38aeb7da3a2a6617">&#9670;&nbsp;</a></span>I2C_masterSendSingleByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_masterSendSingleByte </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>txData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does single byte transmission from Master to Slave</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">txData</td><td>is the data byte to be transmitted</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to send a single byte. This function</p><ul>
<li>Sends START</li>
<li>Transmits the byte to the Slave</li>
<li>Sends STOP</li>
</ul>
<p>Modified registers are <b>UCBxIE</b>, <b>UCBxCTL1</b>, <b>UCBxIFG</b>, <b>UCBxTXBUF</b>, <b>UCBxIE</b> </p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="gaeec9c4fe134818b61ad979643180201a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeec9c4fe134818b61ad979643180201a">&#9670;&nbsp;</a></span>I2C_masterSendSingleByteWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C_masterSendSingleByteWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>txData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does single byte transmission from Master to Slave with timeout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">txData</td><td>is the data byte to be transmitted </td></tr>
    <tr><td class="paramname">timeout</td><td>is the amount of time to wait until giving up</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to send a single byte. This function</p><ul>
<li>Sends START</li>
<li>Transmits the byte to the Slave</li>
<li>Sends STOP</li>
</ul>
<p>Modified registers are <b>UCBxIE</b>, <b>UCBxCTL1</b>, <b>UCBxIFG</b>, <b>UCBxTXBUF</b>, <b>UCBxIE</b> </p>
<dl class="section return"><dt>Returns</dt><dd>0x01 or 0x00URE of the transmission process. </dd></dl>

</div>
</div>
<a id="ga50af773579d945b926b3ced3e9dc3767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50af773579d945b926b3ced3e9dc3767">&#9670;&nbsp;</a></span>I2C_masterSendStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_masterSendStart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used by the Master module to initiate START</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by the Master module to initiate STOP</p>
<p>Modified bits are UCTXSTT bit of UCBxCTLW0.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga11f7ee27e01c7d146f329c152a325d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11f7ee27e01c7d146f329c152a325d91">&#9670;&nbsp;</a></span>I2C_registerInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_registerInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>intHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for I2C interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">intHandler</td><td>is a pointer to the function to be called when the timer capture compare interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers the handler to be called when an I2C interrupt occurs. This function enables the global interrupt in the interrupt controller; specific I2C interrupts must be enabled via <a class="el" href="group__i2c__api.html#gafa37ca83de74b961dd11fcb7884fae50">I2C_enableInterrupt()</a>. It is the interrupt handler's responsibility to clear the interrupt source via <a class="el" href="group__i2c__api.html#gaef0d4264f06934a6765a33da5b203192">I2C_clearInterruptFlag()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#gae2a33716d48a45c7c719304d185c6620">Interrupt_registerInterrupt()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga9bbefbfc634dc34fa6c399144e9c10cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bbefbfc634dc34fa6c399144e9c10cf">&#9670;&nbsp;</a></span>I2C_setMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_setMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the mode of the I2C device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">mode</td><td>indicates whether module is in transmit/receive mode<ul>
<li><b>EUSCI_B_I2C_TRANSMIT_MODE</b> </li>
<li><b>EUSCI_B_I2C_RECEIVE_MODE</b> [Default value]</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Modified bits are <b>UCTR</b> of <b>UCBxCTL1</b> register</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gac81bd3dd72311c4f71ff98a4ffd5f588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac81bd3dd72311c4f71ff98a4ffd5f588">&#9670;&nbsp;</a></span>I2C_setSlaveAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_setSlaveAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>slaveAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the address that the I2C Master will place on the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">slaveAddress</td><td>7-bit or 10-bit slave address</td></tr>
  </table>
  </dd>
</dl>
<p>This function will set the address that the I2C Master will place on the bus when initiating a transaction. Modified register is <b>UCBxI2CSA</b> register</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga713e0ba43ec941d455bbf040de54b526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga713e0ba43ec941d455bbf040de54b526">&#9670;&nbsp;</a></span>I2C_slaveGetData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2C_slaveGetData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receives a byte that has been sent to the I2C Module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads a byte of data from the I2C receive data Register.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte received from by the I2C module, cast as an uint8_t. Modified bit is <b>UCBxRXBUF</b> register </dd></dl>

</div>
</div>
<a id="gad9d79d99135de484c1a5d2b2bdf8a44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9d79d99135de484c1a5d2b2bdf8a44d">&#9670;&nbsp;</a></span>I2C_slavePutData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_slavePutData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>transmitData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transmits a byte from the I2C Module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">transmitData</td><td>data to be transmitted from the I2C module</td></tr>
  </table>
  </dd>
</dl>
<p>This function will place the supplied data into I2C transmit data register to start transmission Modified register is <b>UCBxTXBUF</b> register</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga9692f848ce99e391aef5ba0310fb478b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9692f848ce99e391aef5ba0310fb478b">&#9670;&nbsp;</a></span>I2C_slaveSendNAK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_slaveSendNAK </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used by the slave to send a NAK out over the I2C line</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga7ad6c37df831535294fb7c69c3f8c5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ad6c37df831535294fb7c69c3f8c5ef">&#9670;&nbsp;</a></span>I2C_unregisterInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_unregisterInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters the interrupt handler for the timer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleInstance</td><td>is the instance of the eUSCI B (I2C) module. Valid parameters vary from part to part, but can include:<ul>
<li><b>EUSCI_B0_BASE</b> </li>
<li><b>EUSCI_B1_BASE</b> </li>
<li><b>EUSCI_B2_BASE</b> </li>
<li><b>EUSCI_B3_BASE</b> <br  />
It is important to note that for eUSCI modules, only "B" modules such as EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the I2C mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function unregisters the handler to be called when timer interrupt occurs. This function also masks off the interrupt in the interrupt controller so that the interrupt handler no longer is called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#gae2a33716d48a45c7c719304d185c6620">Interrupt_registerInterrupt()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
