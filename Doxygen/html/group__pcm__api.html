<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vitalsgrafr UY: Pcm_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vitalsgrafr UY
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Pcm_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga99147e526657c3b835d9761759ff08ea"><td class="memItemLeft" align="right" valign="top"><a id="ga99147e526657c3b835d9761759ff08ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_KEY</b>&#160;&#160;&#160;0x695A0000</td></tr>
<tr class="separator:ga99147e526657c3b835d9761759ff08ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd62bbd1bded64bf60ce972b0f144b3e"><td class="memItemLeft" align="right" valign="top"><a id="gafd62bbd1bded64bf60ce972b0f144b3e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_AM_LDO_VCORE0</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gafd62bbd1bded64bf60ce972b0f144b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab61c30bfb8170df65b590dbc5f061822"><td class="memItemLeft" align="right" valign="top"><a id="gab61c30bfb8170df65b590dbc5f061822"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_AM_LDO_VCORE1</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:gab61c30bfb8170df65b590dbc5f061822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1bfcae251c55b634bbedc1f282883e8"><td class="memItemLeft" align="right" valign="top"><a id="gaf1bfcae251c55b634bbedc1f282883e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_AM_DCDC_VCORE0</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:gaf1bfcae251c55b634bbedc1f282883e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87365effd53591e5d2c82db3158465b"><td class="memItemLeft" align="right" valign="top"><a id="gaf87365effd53591e5d2c82db3158465b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_AM_DCDC_VCORE1</b>&#160;&#160;&#160;0x05</td></tr>
<tr class="separator:gaf87365effd53591e5d2c82db3158465b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30b98562b7f7070e203ac843e1b9fd4"><td class="memItemLeft" align="right" valign="top"><a id="gab30b98562b7f7070e203ac843e1b9fd4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_AM_LF_VCORE0</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:gab30b98562b7f7070e203ac843e1b9fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631245b239dc783565fa972641560703"><td class="memItemLeft" align="right" valign="top"><a id="ga631245b239dc783565fa972641560703"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_AM_LF_VCORE1</b>&#160;&#160;&#160;0x09</td></tr>
<tr class="separator:ga631245b239dc783565fa972641560703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace103e19fd988f59e70fec9b4e8bee29"><td class="memItemLeft" align="right" valign="top"><a id="gace103e19fd988f59e70fec9b4e8bee29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LPM0_LDO_VCORE0</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:gace103e19fd988f59e70fec9b4e8bee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e450d3a5268052e2125da914f374aff"><td class="memItemLeft" align="right" valign="top"><a id="ga8e450d3a5268052e2125da914f374aff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LPM0_LDO_VCORE1</b>&#160;&#160;&#160;0x11</td></tr>
<tr class="separator:ga8e450d3a5268052e2125da914f374aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a36b7673d1d8cbdfc00d26f6cc50b0f"><td class="memItemLeft" align="right" valign="top"><a id="ga6a36b7673d1d8cbdfc00d26f6cc50b0f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LPM0_DCDC_VCORE0</b>&#160;&#160;&#160;0x14</td></tr>
<tr class="separator:ga6a36b7673d1d8cbdfc00d26f6cc50b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe212fa6af57fb6581e20fce080c993"><td class="memItemLeft" align="right" valign="top"><a id="ga3fe212fa6af57fb6581e20fce080c993"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LPM0_DCDC_VCORE1</b>&#160;&#160;&#160;0x15</td></tr>
<tr class="separator:ga3fe212fa6af57fb6581e20fce080c993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21f66799f8d79113ea4e383d28bf5ca6"><td class="memItemLeft" align="right" valign="top"><a id="ga21f66799f8d79113ea4e383d28bf5ca6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LPM0_LF_VCORE0</b>&#160;&#160;&#160;0x18</td></tr>
<tr class="separator:ga21f66799f8d79113ea4e383d28bf5ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59adb6f58178d155bf493331283e9499"><td class="memItemLeft" align="right" valign="top"><a id="ga59adb6f58178d155bf493331283e9499"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LPM0_LF_VCORE1</b>&#160;&#160;&#160;0x19</td></tr>
<tr class="separator:ga59adb6f58178d155bf493331283e9499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c93e352c74e674f2569e1754e277cb6"><td class="memItemLeft" align="right" valign="top"><a id="ga0c93e352c74e674f2569e1754e277cb6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LPM3</b>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:ga0c93e352c74e674f2569e1754e277cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c2db282057e4855736f1ec31d3d757"><td class="memItemLeft" align="right" valign="top"><a id="gad1c2db282057e4855736f1ec31d3d757"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LPM4</b>&#160;&#160;&#160;0x21</td></tr>
<tr class="separator:gad1c2db282057e4855736f1ec31d3d757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a099284de8385beb04f10438695bea"><td class="memItemLeft" align="right" valign="top"><a id="gae9a099284de8385beb04f10438695bea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LPM35_VCORE0</b>&#160;&#160;&#160;0xC0</td></tr>
<tr class="separator:gae9a099284de8385beb04f10438695bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3369099804e8ec1bfbdb396fbdab5f3"><td class="memItemLeft" align="right" valign="top"><a id="gae3369099804e8ec1bfbdb396fbdab5f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LPM45</b>&#160;&#160;&#160;0xA0</td></tr>
<tr class="separator:gae3369099804e8ec1bfbdb396fbdab5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae399b099eb6bc8f0b0836677e985e62"><td class="memItemLeft" align="right" valign="top"><a id="gaae399b099eb6bc8f0b0836677e985e62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_VCORE0</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gaae399b099eb6bc8f0b0836677e985e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8248d84a15fa854397b2516e2e3e5290"><td class="memItemLeft" align="right" valign="top"><a id="ga8248d84a15fa854397b2516e2e3e5290"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_VCORE1</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga8248d84a15fa854397b2516e2e3e5290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae255c6c491cf335b0c3a9777b3f7a254"><td class="memItemLeft" align="right" valign="top"><a id="gae255c6c491cf335b0c3a9777b3f7a254"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_VCORELPM3</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:gae255c6c491cf335b0c3a9777b3f7a254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea3880d9ab27db9004ac4f9b991c2c1f"><td class="memItemLeft" align="right" valign="top"><a id="gaea3880d9ab27db9004ac4f9b991c2c1f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LDO_MODE</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gaea3880d9ab27db9004ac4f9b991c2c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2110b687d5cef1fae56323db2f747795"><td class="memItemLeft" align="right" valign="top"><a id="ga2110b687d5cef1fae56323db2f747795"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_DCDC_MODE</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga2110b687d5cef1fae56323db2f747795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac177f4b7ecfce7200a95b5a6bacbf89a"><td class="memItemLeft" align="right" valign="top"><a id="gac177f4b7ecfce7200a95b5a6bacbf89a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_LF_MODE</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:gac177f4b7ecfce7200a95b5a6bacbf89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1536275cd1b086070caf9219948ebada"><td class="memItemLeft" align="right" valign="top"><a id="ga1536275cd1b086070caf9219948ebada"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_SHUTDOWN_PARTIAL</b>&#160;&#160;&#160;PCM_LPM35_VCORE0</td></tr>
<tr class="separator:ga1536275cd1b086070caf9219948ebada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac091b7ed755f0e16ddeba7d07b79c082"><td class="memItemLeft" align="right" valign="top"><a id="gac091b7ed755f0e16ddeba7d07b79c082"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_SHUTDOWN_COMPLETE</b>&#160;&#160;&#160;PCM_LPM45</td></tr>
<tr class="separator:gac091b7ed755f0e16ddeba7d07b79c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8ff7c7449e8317f4ff3865d2b9ab52"><td class="memItemLeft" align="right" valign="top"><a id="ga0c8ff7c7449e8317f4ff3865d2b9ab52"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_DCDCERROR</b>&#160;&#160;&#160;PCM_IE_DCDC_ERROR_IE</td></tr>
<tr class="separator:ga0c8ff7c7449e8317f4ff3865d2b9ab52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f62051eeb1722ed3ac4dfcad18ab75"><td class="memItemLeft" align="right" valign="top"><a id="ga60f62051eeb1722ed3ac4dfcad18ab75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_AM_INVALIDTRANSITION</b>&#160;&#160;&#160;PCM_IE_AM_INVALID_TR_IE</td></tr>
<tr class="separator:ga60f62051eeb1722ed3ac4dfcad18ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9a1fc50fe6e5e404cf856acb67ef564"><td class="memItemLeft" align="right" valign="top"><a id="gaa9a1fc50fe6e5e404cf856acb67ef564"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_SM_INVALIDCLOCK</b>&#160;&#160;&#160;PCM_IE_LPM_INVALID_CLK_IE</td></tr>
<tr class="separator:gaa9a1fc50fe6e5e404cf856acb67ef564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7430605713d765d35c44b988d6ab468f"><td class="memItemLeft" align="right" valign="top"><a id="ga7430605713d765d35c44b988d6ab468f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCM_SM_INVALIDTRANSITION</b>&#160;&#160;&#160;PCM_IE_LPM_INVALID_TR_IE</td></tr>
<tr class="separator:ga7430605713d765d35c44b988d6ab468f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaadb3d2e085a27d5e2cebe84196533fe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaadb3d2e085a27d5e2cebe84196533fe3">PCM_setCoreVoltageLevel</a> (uint_fast8_t voltageLevel)</td></tr>
<tr class="separator:gaadb3d2e085a27d5e2cebe84196533fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e55a8228de10311eacbdb0bde780ac4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel</a> (void)</td></tr>
<tr class="separator:ga1e55a8228de10311eacbdb0bde780ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc18be0c36ea2be20b7d108543b1f8eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gabc18be0c36ea2be20b7d108543b1f8eb">PCM_setCoreVoltageLevelWithTimeout</a> (uint_fast8_t voltageLevel, uint32_t timeOut)</td></tr>
<tr class="separator:gabc18be0c36ea2be20b7d108543b1f8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f3a6d5eaef8339d3242f9cb0120adc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga7f3a6d5eaef8339d3242f9cb0120adc8">PCM_setCoreVoltageLevelNonBlocking</a> (uint_fast8_t voltageLevel)</td></tr>
<tr class="separator:ga7f3a6d5eaef8339d3242f9cb0120adc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bbba40f896f89b792b78f4b54b0078d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga5bbba40f896f89b792b78f4b54b0078d">PCM_setPowerMode</a> (uint_fast8_t powerMode)</td></tr>
<tr class="separator:ga5bbba40f896f89b792b78f4b54b0078d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78385c4c1a29ba989a995eef9d0bf4b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga78385c4c1a29ba989a995eef9d0bf4b3">PCM_setPowerModeWithTimeout</a> (uint_fast8_t powerMode, uint32_t timeOut)</td></tr>
<tr class="separator:ga78385c4c1a29ba989a995eef9d0bf4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9265c253e2ef1d848edf31ad200ad94a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga9265c253e2ef1d848edf31ad200ad94a">PCM_setPowerModeNonBlocking</a> (uint_fast8_t powerMode)</td></tr>
<tr class="separator:ga9265c253e2ef1d848edf31ad200ad94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98797f17f6b52e66b8eb42b86f0c2e1d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode</a> (void)</td></tr>
<tr class="separator:ga98797f17f6b52e66b8eb42b86f0c2e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcfe9e81af9f912ad010dea02a84e1dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gadcfe9e81af9f912ad010dea02a84e1dd">PCM_setPowerState</a> (uint_fast8_t powerState)</td></tr>
<tr class="separator:gadcfe9e81af9f912ad010dea02a84e1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013ca7d7d9540e55ccce332ddac37c3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga013ca7d7d9540e55ccce332ddac37c3a">PCM_setPowerStateWithTimeout</a> (uint_fast8_t powerState, uint32_t timeout)</td></tr>
<tr class="separator:ga013ca7d7d9540e55ccce332ddac37c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd3e28f2cf736397d7849b13e29e086"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga0fd3e28f2cf736397d7849b13e29e086">PCM_getPowerState</a> (void)</td></tr>
<tr class="separator:ga0fd3e28f2cf736397d7849b13e29e086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e54ae81e8ba5c30fabd3c126a5eda0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga2e54ae81e8ba5c30fabd3c126a5eda0a">PCM_setPowerStateNonBlocking</a> (uint_fast8_t powerState)</td></tr>
<tr class="separator:ga2e54ae81e8ba5c30fabd3c126a5eda0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a4f38b56ffdfa166f74de92b64ea08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaf8a4f38b56ffdfa166f74de92b64ea08">PCM_shutdownDevice</a> (uint32_t shutdownMode)</td></tr>
<tr class="separator:gaf8a4f38b56ffdfa166f74de92b64ea08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe310d00db05c52931b714da4c11b7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaffe310d00db05c52931b714da4c11b7d">PCM_gotoLPM0</a> (void)</td></tr>
<tr class="separator:gaffe310d00db05c52931b714da4c11b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629a4ca61ca8813a231250057d426885"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3</a> (void)</td></tr>
<tr class="separator:ga629a4ca61ca8813a231250057d426885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1d3320b552e378c333c37fad34517a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaf1d3320b552e378c333c37fad34517a3">PCM_gotoLPM0InterruptSafe</a> (void)</td></tr>
<tr class="separator:gaf1d3320b552e378c333c37fad34517a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bf9fd4192110e273db7648dae87de3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga3bf9fd4192110e273db7648dae87de3d">PCM_gotoLPM3InterruptSafe</a> (void)</td></tr>
<tr class="separator:ga3bf9fd4192110e273db7648dae87de3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd8029aa4c1db3892bbe3e93af840b31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gacd8029aa4c1db3892bbe3e93af840b31">PCM_gotoLPM4</a> (void)</td></tr>
<tr class="separator:gacd8029aa4c1db3892bbe3e93af840b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e450f968451a50c570baa972e37250a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga2e450f968451a50c570baa972e37250a">PCM_gotoLPM4InterruptSafe</a> (void)</td></tr>
<tr class="separator:ga2e450f968451a50c570baa972e37250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4787884be1ce9ed19008fad506d3036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaf4787884be1ce9ed19008fad506d3036">PCM_enableRudeMode</a> (void)</td></tr>
<tr class="separator:gaf4787884be1ce9ed19008fad506d3036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022c681cdc82a9a729d4c6491fa04fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga022c681cdc82a9a729d4c6491fa04fdd">PCM_disableRudeMode</a> (void)</td></tr>
<tr class="separator:ga022c681cdc82a9a729d4c6491fa04fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa13b8e1cdcad429be17abf93ef32b55e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaa13b8e1cdcad429be17abf93ef32b55e">PCM_enableInterrupt</a> (uint32_t flags)</td></tr>
<tr class="separator:gaa13b8e1cdcad429be17abf93ef32b55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57c6fa2c61a09135ec4ad2467b465ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga57c6fa2c61a09135ec4ad2467b465ac2">PCM_disableInterrupt</a> (uint32_t flags)</td></tr>
<tr class="separator:ga57c6fa2c61a09135ec4ad2467b465ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13480f488469c23521b1c583c6869b37"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga13480f488469c23521b1c583c6869b37">PCM_getInterruptStatus</a> (void)</td></tr>
<tr class="separator:ga13480f488469c23521b1c583c6869b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e666dad597a14a2ed14220bf1045862"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga2e666dad597a14a2ed14220bf1045862">PCM_getEnabledInterruptStatus</a> (void)</td></tr>
<tr class="separator:ga2e666dad597a14a2ed14220bf1045862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63181a0fc0044f9db7e5666706a51b4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga63181a0fc0044f9db7e5666706a51b4d">PCM_clearInterruptFlag</a> (uint32_t flags)</td></tr>
<tr class="separator:ga63181a0fc0044f9db7e5666706a51b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9994d27c2640ad8f86173f0ec36a383d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga9994d27c2640ad8f86173f0ec36a383d">PCM_registerInterrupt</a> (void(*intHandler)(void))</td></tr>
<tr class="separator:ga9994d27c2640ad8f86173f0ec36a383d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a6b73614bd5c9fe03650563624ffcc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga8a6b73614bd5c9fe03650563624ffcc1">PCM_unregisterInterrupt</a> (void)</td></tr>
<tr class="separator:ga8a6b73614bd5c9fe03650563624ffcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga63181a0fc0044f9db7e5666706a51b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63181a0fc0044f9db7e5666706a51b4d">&#9670;&nbsp;</a></span>PCM_clearInterruptFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_clearInterruptFlag </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears power system interrupt sources.</p>
<p>The specified power system interrupt sources are cleared, so that they no longer assert. This function must be called in the interrupt handler to keep it from being called again immediately upon exit.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>is a bit mask of the interrupt sources to be cleared. Must be a logical OR of<ul>
<li><b>PCM_DCDCERROR</b>,</li>
<li><b>PCM_AM_INVALIDTRANSITION</b>,</li>
<li><b>PCM_SM_INVALIDCLOCK</b>,</li>
<li><b>PCM_SM_INVALIDTRANSITION</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga57c6fa2c61a09135ec4ad2467b465ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57c6fa2c61a09135ec4ad2467b465ac2">&#9670;&nbsp;</a></span>PCM_disableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables individual power control interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>is a bit mask of the interrupt sources to be enabled. Must be a logical OR of:<ul>
<li><b>PCM_DCDCERROR</b>,</li>
<li><b>PCM_AM_INVALIDTRANSITION</b>,</li>
<li><b>PCM_SM_INVALIDCLOCK</b>,</li>
<li><b>PCM_SM_INVALIDTRANSITION</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated power control interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga022c681cdc82a9a729d4c6491fa04fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga022c681cdc82a9a729d4c6491fa04fdd">&#9670;&nbsp;</a></span>PCM_disableRudeMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_disableRudeMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables "rude mode" entry into LPM3 and shutdown modes. With this mode disabled, an entry into shutdown or LPM3 will wait for any active clock requests to free up before going into LPM3 or shutdown.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa13b8e1cdcad429be17abf93ef32b55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa13b8e1cdcad429be17abf93ef32b55e">&#9670;&nbsp;</a></span>PCM_enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables individual power control interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>is a bit mask of the interrupt sources to be enabled. Must be a logical OR of:<ul>
<li><b>PCM_DCDCERROR</b>,</li>
<li><b>PCM_AM_INVALIDTRANSITION</b>,</li>
<li><b>PCM_SM_INVALIDCLOCK</b>,</li>
<li><b>PCM_SM_INVALIDTRANSITION</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated power control interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaf4787884be1ce9ed19008fad506d3036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4787884be1ce9ed19008fad506d3036">&#9670;&nbsp;</a></span>PCM_enableRudeMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_enableRudeMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables "rude mode" entry into LPM3 and shutdown modes. With this mode enabled, an entry into shutdown or LPM3 will occur even if there are clock systems active. The system will forcibly turn off all clock/systems when going into these modes.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga1e55a8228de10311eacbdb0bde780ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e55a8228de10311eacbdb0bde780ac4">&#9670;&nbsp;</a></span>PCM_getCoreVoltageLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PCM_getCoreVoltageLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current powers state of the system see the PCM_setCoreVoltageLevel function for specific information about the modes.</p>
<dl class="section return"><dt>Returns</dt><dd>The current voltage of the system</dd></dl>
<p>Possible return values include:</p><ul>
<li><b>PCM_VCORE0</b> </li>
<li><b>PCM_VCORE1</b> </li>
<li><b>PCM_VCORELPM3</b> </li>
</ul>

</div>
</div>
<a id="ga2e666dad597a14a2ed14220bf1045862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e666dad597a14a2ed14220bf1045862">&#9670;&nbsp;</a></span>PCM_getEnabledInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PCM_getEnabledInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current interrupt status masked with the enabled interrupts. This function is useful to call in ISRs to get a list of pending interrupts that are actually enabled and could have caused the ISR.</p>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt status, enumerated as a bit field of:<ul>
<li><b>PCM_DCDCERROR</b>,</li>
<li><b>PCM_AM_INVALIDTRANSITION</b>,</li>
<li><b>PCM_SM_INVALIDCLOCK</b>,</li>
<li><b>PCM_SM_INVALIDTRANSITION</b> </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available. </dd></dl>

</div>
</div>
<a id="ga13480f488469c23521b1c583c6869b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13480f488469c23521b1c583c6869b37">&#9670;&nbsp;</a></span>PCM_getInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PCM_getInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current interrupt status.</p>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt status, enumerated as a bit field of:<ul>
<li><b>PCM_DCDCERROR</b>,</li>
<li><b>PCM_AM_INVALIDTRANSITION</b>,</li>
<li><b>PCM_SM_INVALIDCLOCK</b>,</li>
<li><b>PCM_SM_INVALIDTRANSITION</b> </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available. </dd></dl>

</div>
</div>
<a id="ga98797f17f6b52e66b8eb42b86f0c2e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98797f17f6b52e66b8eb42b86f0c2e1d">&#9670;&nbsp;</a></span>PCM_getPowerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PCM_getPowerMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current powers state of the system see the <b>PCM_setPowerState</b> function for specific information about the modes.</p>
<dl class="section return"><dt>Returns</dt><dd>The current power mode of the system </dd></dl>

</div>
</div>
<a id="ga0fd3e28f2cf736397d7849b13e29e086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fd3e28f2cf736397d7849b13e29e086">&#9670;&nbsp;</a></span>PCM_getPowerState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PCM_getPowerState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current powers state of the system see the PCMChangePowerState function for specific information about the states.</p>
<p>Refer to <a class="el" href="group__pcm__api.html#gadcfe9e81af9f912ad010dea02a84e1dd">PCM_setPowerState</a> for possible return values.</p>
<dl class="section return"><dt>Returns</dt><dd>The current power state of the system </dd></dl>

</div>
</div>
<a id="gaffe310d00db05c52931b714da4c11b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffe310d00db05c52931b714da4c11b7d">&#9670;&nbsp;</a></span>PCM_gotoLPM0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM0.</p>
<p>Refer to the device specific data sheet for specifics about low power modes.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

</div>
</div>
<a id="gaf1d3320b552e378c333c37fad34517a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1d3320b552e378c333c37fad34517a3">&#9670;&nbsp;</a></span>PCM_gotoLPM0InterruptSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM0InterruptSafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM0 while maintaining a safe interrupt handling mentality. This function is meant to be used in situations where the user wants to go to sleep, however does not want to go to "miss" any interrupts due to the fact that going to LPM0 is not an atomic operation. This function will modify the PRIMASK and on exit of the program the master interrupts will be disabled.</p>
<p>Refer to the device specific data sheet for specifics about low power modes.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

</div>
</div>
<a id="ga629a4ca61ca8813a231250057d426885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga629a4ca61ca8813a231250057d426885">&#9670;&nbsp;</a></span>PCM_gotoLPM3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM3 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM3</p>
<p>Refer to the device specific data sheet for specifics about low power modes. Note that since LPM3 cannot be entered from a DCDC power modes, the power mode is first switched to LDO operation (if in DCDC mode), the deep sleep is entered, and the DCDC mode is restored on wake up.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

</div>
</div>
<a id="ga3bf9fd4192110e273db7648dae87de3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bf9fd4192110e273db7648dae87de3d">&#9670;&nbsp;</a></span>PCM_gotoLPM3InterruptSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM3InterruptSafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM3 while maintaining a safe interrupt handling mentality. This function is meant to be used in situations where the user wants to go to LPM3, however does not want to go to "miss" any interrupts due to the fact that going to LPM3 is not an atomic operation. This function will modify the PRIMASK and on exit of the program the master interrupts will be disabled.</p>
<p>Refer to the device specific data sheet for specifics about low power modes. Note that since LPM3 cannot be entered from a DCDC power modes, the power mode is first switched to LDO operation (if in DCDC mode), the deep sleep is entered, and the DCDC mode is restored on wake up.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

</div>
</div>
<a id="gacd8029aa4c1db3892bbe3e93af840b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd8029aa4c1db3892bbe3e93af840b31">&#9670;&nbsp;</a></span>PCM_gotoLPM4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM4 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM4. LPM4 is the exact same with LPM3, just with RTC_C and WDT_A disabled. When waking up, RTC_C and WDT_A will remain disabled until reconfigured by the user.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

</div>
</div>
<a id="ga2e450f968451a50c570baa972e37250a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e450f968451a50c570baa972e37250a">&#9670;&nbsp;</a></span>PCM_gotoLPM4InterruptSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM4InterruptSafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM4 while maintaining a safe interrupt handling mentality. This function is meant to be used in situations where the user wants to go to LPM4, however does not want to go to "miss" any interrupts due to the fact that going to LPM4 is not an atomic operation. This function will modify the PRIMASK and on exit of the program the master interrupts will be disabled.</p>
<p>Refer to the device specific data sheet for specifics about low power modes. Note that since LPM3 cannot be entered from a DCDC power modes, the power mode is first switched to LDO operation (if in DCDC mode), the deep sleep is entered, and the DCDC mode is restored on wake up.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

</div>
</div>
<a id="ga9994d27c2640ad8f86173f0ec36a383d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9994d27c2640ad8f86173f0ec36a383d">&#9670;&nbsp;</a></span>PCM_registerInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_registerInterrupt </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>intHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for the power system interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intHandler</td><td>is a pointer to the function to be called when the power system interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers the handler to be called when a clock system interrupt occurs. This function enables the global interrupt in the interrupt controller; specific PCM interrupts must be enabled via <a class="el" href="group__pcm__api.html#gaa13b8e1cdcad429be17abf93ef32b55e">PCM_enableInterrupt()</a>. It is the interrupt handler's responsibility to clear the interrupt source via <a class="el" href="group__pcm__api.html#ga63181a0fc0044f9db7e5666706a51b4d">PCM_clearInterruptFlag</a> .</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#gae2a33716d48a45c7c719304d185c6620">Interrupt_registerInterrupt()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaadb3d2e085a27d5e2cebe84196533fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadb3d2e085a27d5e2cebe84196533fe3">&#9670;&nbsp;</a></span>PCM_setCoreVoltageLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setCoreVoltageLevel </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>voltageLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the core voltage level (Vcore). The function will take care of all power state transitions needed to shift between core voltage levels. Because transitions between voltage levels may require changes power modes, the power mode might temporarily be change. The power mode will be returned to the original state (with the new voltage level) at the end of a successful execution of this function.</p>
<p>Refer to the device specific data sheet for specifics about core voltage levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltageLevel</td><td>The voltage level to be shifted to.<ul>
<li><b>PCM_VCORE0</b>,</li>
<li><b>PCM_VCORE1</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if voltage level set, false otherwise. </dd></dl>

</div>
</div>
<a id="ga7f3a6d5eaef8339d3242f9cb0120adc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f3a6d5eaef8339d3242f9cb0120adc8">&#9670;&nbsp;</a></span>PCM_setCoreVoltageLevelNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setCoreVoltageLevelNonBlocking </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>voltageLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the core voltage level (Vcore). This function is similar to PCM_setCoreVoltageLevel, however there are no polling flags to ensure a state has changed. Execution is returned back to the calling program correctly. For MSP432, changing into different power modes/states require very specific logic. This function will initiate only one state transition and then return. It is up to the user to keep calling this function until the correct power state has been achieved.</p>
<p>Refer to the device specific data sheet for specifics about core voltage levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltageLevel</td><td>The voltage level to be shifted to.<ul>
<li><b>PCM_VCORE0</b>,</li>
<li><b>PCM_VCORE1</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if voltage level set, false otherwise. </dd></dl>

</div>
</div>
<a id="gabc18be0c36ea2be20b7d108543b1f8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc18be0c36ea2be20b7d108543b1f8eb">&#9670;&nbsp;</a></span>PCM_setCoreVoltageLevelWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setCoreVoltageLevelWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>voltageLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the core voltage level (Vcore). This function will take care of all power state transitions needed to shift between core voltage levels. Because transitions between voltage levels may require changes power modes, the power mode might temporarily be change. The power mode will be returned to the original state (with the new voltage level) at the end of a successful execution of this function.</p>
<p>This function is similar to PCMSetCoreVoltageLevel, however a timeout mechanism is used.</p>
<p>Refer to the device specific data sheet for specifics about core voltage levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltageLevel</td><td>The voltage level to be shifted to.<ul>
<li><b>PCM_VCORE0</b>,</li>
<li><b>PCM_VCORE1</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">timeOut</td><td>Number of loop iterations to timeout when checking for power state transitions. This should be used for debugging initial power/hardware configurations. After a stable hardware base is established, the PCMSetCoreVoltageLevel function should be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if voltage level set, false otherwise. </dd></dl>

</div>
</div>
<a id="ga5bbba40f896f89b792b78f4b54b0078d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bbba40f896f89b792b78f4b54b0078d">&#9670;&nbsp;</a></span>PCM_setPowerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerMode </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switches between power modes. This function will take care of all power state transitions needed to shift between power modes. Note for changing to DCDC mode, specific hardware considerations are required.</p>
<p>Refer to the device specific data sheet for specifics about power modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerMode</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_LDO_MODE</b>,</li>
<li><b>PCM_DCDC_MODE</b>,</li>
<li><b>PCM_LF_MODE</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power mode is set, false otherwise. </dd></dl>

</div>
</div>
<a id="ga9265c253e2ef1d848edf31ad200ad94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9265c253e2ef1d848edf31ad200ad94a">&#9670;&nbsp;</a></span>PCM_setPowerModeNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerModeNonBlocking </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the core voltage level (Vcore). This function is similar to PCM_setPowerMode, however there are no polling flags to ensure a state has changed. Execution is returned back to the calling program correctly. For MSP432, changing into different power modes/states require very specific logic. This function will initiate only one state transition and then return. It is up to the user to keep calling this function until the correct power state has been achieved.</p>
<p>Refer to the device specific data sheet for specifics about core voltage levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerMode</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_LDO_MODE</b>,</li>
<li><b>PCM_DCDC_MODE</b>,</li>
<li><b>PCM_LF_MODE</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power mode change was initiated, false otherwise </dd></dl>

</div>
</div>
<a id="ga78385c4c1a29ba989a995eef9d0bf4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78385c4c1a29ba989a995eef9d0bf4b3">&#9670;&nbsp;</a></span>PCM_setPowerModeWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerModeWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switches between power modes. This function will take care of all power state transitions needed to shift between power modes. Note for changing to DCDC mode, specific hardware considerations are required.</p>
<p>This function is similar to PCMSetPowerMode, however a timeout mechanism is used.</p>
<p>Refer to the device specific data sheet for specifics about power modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerMode</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_LDO_MODE</b>,</li>
<li><b>PCM_DCDC_MODE</b>,</li>
<li><b>PCM_LF_MODE</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">timeOut</td><td>Number of loop iterations to timeout when checking for power state transitions. This should be used for debugging initial power/hardware configurations. After a stable hardware base is established, the PCMSetPowerMode function should be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power mode is set, false otherwise. </dd></dl>

</div>
</div>
<a id="gadcfe9e81af9f912ad010dea02a84e1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcfe9e81af9f912ad010dea02a84e1dd">&#9670;&nbsp;</a></span>PCM_setPowerState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerState </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switches between power states. This is a convenience function that combines the functionality of PCM_setPowerMode and PCM_setCoreVoltageLevel as well as the LPM0/LPM3 functions.</p>
<p>Refer to the device specific data sheet for specifics about power states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerState</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_AM_LDO_VCORE0</b>, [Active Mode, LDO, VCORE0]</li>
<li><b>PCM_AM_LDO_VCORE1</b>, [Active Mode, LDO, VCORE1]</li>
<li><b>PCM_AM_DCDC_VCORE0</b>, [Active Mode, DCDC, VCORE0]</li>
<li><b>PCM_AM_DCDC_VCORE1</b>, [Active Mode, DCDC, VCORE1]</li>
<li><b>PCM_AM_LF_VCORE0</b>, [Active Mode, Low Frequency, VCORE0]</li>
<li><b>PCM_AM_LF_VCORE1</b>, [Active Mode, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM0_LDO_VCORE0</b>, [LMP0, LDO, VCORE0]</li>
<li><b>PCM_LPM0_LDO_VCORE1</b>, [LMP0, LDO, VCORE1]</li>
<li><b>PCM_LPM0_DCDC_VCORE0</b>, [LMP0, DCDC, VCORE0]</li>
<li><b>PCM_LPM0_DCDC_VCORE1</b>, [LMP0, DCDC, VCORE1]</li>
<li><b>PCM_LPM0_LF_VCORE0</b>, [LMP0, Low Frequency, VCORE0]</li>
<li><b>PCM_LPM0_LF_VCORE1</b>, [LMP0, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM3</b>, [LPM3]</li>
<li><b>PCM_LPM35_VCORE0</b>, [LPM3.5 VCORE 0]</li>
<li><b>PCM_LPM4</b>, [LPM4]</li>
<li><b>PCM_LPM45</b>, [LPM4.5]</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power state is set, false otherwise. </dd></dl>

</div>
</div>
<a id="ga2e54ae81e8ba5c30fabd3c126a5eda0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e54ae81e8ba5c30fabd3c126a5eda0a">&#9670;&nbsp;</a></span>PCM_setPowerStateNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerStateNonBlocking </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the power state of the part. This function is similar to PCM_getPowerState, however there are no polling flags to ensure a state has changed. Execution is returned back to the calling program correctly. For MSP432, changing into different power modes/states require very specific logic. This function will initiate only one state transition and then return. It is up to the user to keep calling this function until the correct power state has been achieved.</p>
<p>Refer to the device specific data sheet for specifics about core voltage levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerState</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_AM_LDO_VCORE0</b>, [Active Mode, LDO, VCORE0]</li>
<li><b>PCM_AM_LDO_VCORE1</b>, [Active Mode, LDO, VCORE1]</li>
<li><b>PCM_AM_DCDC_VCORE0</b>, [Active Mode, DCDC, VCORE0]</li>
<li><b>PCM_AM_DCDC_VCORE1</b>, [Active Mode, DCDC, VCORE1]</li>
<li><b>PCM_AM_LF_VCORE0</b>, [Active Mode, Low Frequency, VCORE0]</li>
<li><b>PCM_AM_LF_VCORE1</b>, [Active Mode, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM0_LDO_VCORE0</b>, [LMP0, LDO, VCORE0]</li>
<li><b>PCM_LPM0_LDO_VCORE1</b>, [LMP0, LDO, VCORE1]</li>
<li><b>PCM_LPM0_DCDC_VCORE0</b>, [LMP0, DCDC, VCORE0]</li>
<li><b>PCM_LPM0_DCDC_VCORE1</b>, [LMP0, DCDC, VCORE1]</li>
<li><b>PCM_LPM0_LF_VCORE0</b>, [LMP0, Low Frequency, VCORE0]</li>
<li><b>PCM_LPM0_LF_VCORE1</b>, [LMP0, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM3</b>, [LPM3]</li>
<li><b>PCM_LPM35_VCORE0</b>, [LPM3.5 VCORE 0]</li>
<li><b>PCM_LPM45</b>, [LPM4.5]</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power state change was initiated, false otherwise </dd></dl>

</div>
</div>
<a id="ga013ca7d7d9540e55ccce332ddac37c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga013ca7d7d9540e55ccce332ddac37c3a">&#9670;&nbsp;</a></span>PCM_setPowerStateWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerStateWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switches between power states. This is a convenience function that combines the functionality of PCM_setPowerMode and PCM_setCoreVoltageLevel as well as the LPM modes.</p>
<p>This function is similar to PCM_setPowerState, however a timeout mechanism is used.</p>
<p>Refer to the device specific data sheet for specifics about power states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerState</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_AM_LDO_VCORE0</b>, [Active Mode, LDO, VCORE0]</li>
<li><b>PCM_AM_LDO_VCORE1</b>, [Active Mode, LDO, VCORE1]</li>
<li><b>PCM_AM_DCDC_VCORE0</b>, [Active Mode, DCDC, VCORE0]</li>
<li><b>PCM_AM_DCDC_VCORE1</b>, [Active Mode, DCDC, VCORE1]</li>
<li><b>PCM_AM_LF_VCORE0</b>, [Active Mode, Low Frequency, VCORE0]</li>
<li><b>PCM_AM_LF_VCORE1</b>, [Active Mode, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM0_LDO_VCORE0</b>, [LMP0, LDO, VCORE0]</li>
<li><b>PCM_LPM0_LDO_VCORE1</b>, [LMP0, LDO, VCORE1]</li>
<li><b>PCM_LPM0_DCDC_VCORE0</b>, [LMP0, DCDC, VCORE0]</li>
<li><b>PCM_LPM0_DCDC_VCORE1</b>, [LMP0, DCDC, VCORE1]</li>
<li><b>PCM_LPM0_LF_VCORE0</b>, [LMP0, Low Frequency, VCORE0]</li>
<li><b>PCM_LPM0_LF_VCORE1</b>, [LMP0, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM3</b>, [LPM3]</li>
<li><b>PCM_LPM35_VCORE0</b>, [LPM3.5 VCORE 0]</li>
<li><b>PCM_LPM4</b>, [LPM4]</li>
<li><b>PCM_LPM45</b>, [LPM4.5]</li>
</ul>
</td></tr>
    <tr><td class="paramname">timeout</td><td>Number of loop iterations to timeout when checking for power state transitions. This should be used for debugging initial power/hardware configurations. After a stable hardware base is established, the PCMSetPowerMode function should be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power state is set, false otherwise. It is important to note that if a timeout occurs, false will be returned, however the power state at this point is not guaranteed to be the same as the state prior to the function call </dd></dl>

</div>
</div>
<a id="gaf8a4f38b56ffdfa166f74de92b64ea08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8a4f38b56ffdfa166f74de92b64ea08">&#9670;&nbsp;</a></span>PCM_shutdownDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_shutdownDevice </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shutdownMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM3.5/LPM4.5 mode.</p>
<p>Refer to the device specific data sheet for specifics about shutdown modes.</p>
<p>The following events will cause a wake up from LPM3.5 mode:</p><ul>
<li>Device reset</li>
<li>External reset RST</li>
<li>Enabled RTC, WDT, and wake-up I/O only interrupt events</li>
</ul>
<p>The following events will cause a wake up from the LPM4.5 mode:</p><ul>
<li>Device reset</li>
<li>External reset RST</li>
<li>Wake-up I/O only interrupt events</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shutdownMode</td><td>Specific mode to go to. Valid values are:<ul>
<li><b>PCM_LPM35_VCORE0</b> </li>
<li><b>PCM_LPM45</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if shutdown state cannot be entered, true otherwise. </dd></dl>

</div>
</div>
<a id="ga8a6b73614bd5c9fe03650563624ffcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a6b73614bd5c9fe03650563624ffcc1">&#9670;&nbsp;</a></span>PCM_unregisterInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_unregisterInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters the interrupt handler for the power system.</p>
<p>This function unregisters the handler to be called when a power system interrupt occurs. This function also masks off the interrupt in the interrupt controller so that the interrupt handler no longer is called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#gae2a33716d48a45c7c719304d185c6620">Interrupt_registerInterrupt()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
