<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vitalsgrafr UY: Hardware Transport Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vitalsgrafr UY
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Hardware Transport Interface<div class="ingroups"><a class="el" href="group___porting.html">Porting</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The simple link device can work with different transport interfaces (namely,SPI or UART). Texas Instruments provides single driver that can work with all these types. This section binds the physical transport interface with the SimpleLink driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabf833fd504ddd56dffe7bd698ede5a9d"><td class="memItemLeft" align="right" valign="top"><a id="gabf833fd504ddd56dffe7bd698ede5a9d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_SlFd_t</b>&#160;&#160;&#160;int</td></tr>
<tr class="separator:gabf833fd504ddd56dffe7bd698ede5a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206e7c86da4e31989d54dbd8531ce505"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#ga206e7c86da4e31989d54dbd8531ce505">sl_IfOpen</a>&#160;&#160;&#160;spi_Open</td></tr>
<tr class="memdesc:ga206e7c86da4e31989d54dbd8531ce505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an interface communication port to be used for communicating with a SimpleLink device.  <a href="group__porting__interface.html#ga206e7c86da4e31989d54dbd8531ce505">More...</a><br /></td></tr>
<tr class="separator:ga206e7c86da4e31989d54dbd8531ce505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d829306f92470614ca2fe71e7fbaa2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#ga93d829306f92470614ca2fe71e7fbaa2">sl_IfClose</a>&#160;&#160;&#160;spi_Close</td></tr>
<tr class="memdesc:ga93d829306f92470614ca2fe71e7fbaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an opened interface communication port.  <a href="group__porting__interface.html#ga93d829306f92470614ca2fe71e7fbaa2">More...</a><br /></td></tr>
<tr class="separator:ga93d829306f92470614ca2fe71e7fbaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4d3db7b5ee6efcaf940de38f32d190"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#ga0d4d3db7b5ee6efcaf940de38f32d190">sl_IfRead</a>&#160;&#160;&#160;spi_Read</td></tr>
<tr class="memdesc:ga0d4d3db7b5ee6efcaf940de38f32d190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read up to len bytes from an opened communication channel into a buffer starting at pBuff.  <a href="group__porting__interface.html#ga0d4d3db7b5ee6efcaf940de38f32d190">More...</a><br /></td></tr>
<tr class="separator:ga0d4d3db7b5ee6efcaf940de38f32d190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca4940235fc8e01cdad18a0908fda34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#gaaca4940235fc8e01cdad18a0908fda34">sl_IfWrite</a>&#160;&#160;&#160;spi_Write</td></tr>
<tr class="memdesc:gaaca4940235fc8e01cdad18a0908fda34"><td class="mdescLeft">&#160;</td><td class="mdescRight">attempts to write up to len bytes to the SPI channel  <a href="group__porting__interface.html#gaaca4940235fc8e01cdad18a0908fda34">More...</a><br /></td></tr>
<tr class="separator:gaaca4940235fc8e01cdad18a0908fda34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e17e205005322be3b619eeeeec9f069"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#ga0e17e205005322be3b619eeeeec9f069">sl_IfRegIntHdlr</a>(InterruptHdl,  pValue)&#160;&#160;&#160;registerInterruptHandler(InterruptHdl , pValue)</td></tr>
<tr class="memdesc:ga0e17e205005322be3b619eeeeec9f069"><td class="mdescLeft">&#160;</td><td class="mdescRight">register an interrupt handler routine for the host IRQ  <a href="group__porting__interface.html#ga0e17e205005322be3b619eeeeec9f069">More...</a><br /></td></tr>
<tr class="separator:ga0e17e205005322be3b619eeeeec9f069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134a6c4658baae78724989e8a36d7be0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#ga134a6c4658baae78724989e8a36d7be0">sl_IfMaskIntHdlr</a>()</td></tr>
<tr class="memdesc:ga134a6c4658baae78724989e8a36d7be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masks the Host IRQ.  <a href="group__porting__interface.html#ga134a6c4658baae78724989e8a36d7be0">More...</a><br /></td></tr>
<tr class="separator:ga134a6c4658baae78724989e8a36d7be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b2a3ae727a4e932ee45ea17fe4f701"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#gab3b2a3ae727a4e932ee45ea17fe4f701">sl_IfUnMaskIntHdlr</a>()</td></tr>
<tr class="memdesc:gab3b2a3ae727a4e932ee45ea17fe4f701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmasks the Host IRQ.  <a href="group__porting__interface.html#gab3b2a3ae727a4e932ee45ea17fe4f701">More...</a><br /></td></tr>
<tr class="separator:gab3b2a3ae727a4e932ee45ea17fe4f701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf833fd504ddd56dffe7bd698ede5a9d"><td class="memItemLeft" align="right" valign="top"><a id="gabf833fd504ddd56dffe7bd698ede5a9d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_SlFd_t</b></td></tr>
<tr class="separator:gabf833fd504ddd56dffe7bd698ede5a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206e7c86da4e31989d54dbd8531ce505"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#ga206e7c86da4e31989d54dbd8531ce505">sl_IfOpen</a></td></tr>
<tr class="memdesc:ga206e7c86da4e31989d54dbd8531ce505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an interface communication port to be used for communicating with a SimpleLink device.  <a href="group__porting__interface.html#ga206e7c86da4e31989d54dbd8531ce505">More...</a><br /></td></tr>
<tr class="separator:ga206e7c86da4e31989d54dbd8531ce505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d829306f92470614ca2fe71e7fbaa2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#ga93d829306f92470614ca2fe71e7fbaa2">sl_IfClose</a></td></tr>
<tr class="memdesc:ga93d829306f92470614ca2fe71e7fbaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an opened interface communication port.  <a href="group__porting__interface.html#ga93d829306f92470614ca2fe71e7fbaa2">More...</a><br /></td></tr>
<tr class="separator:ga93d829306f92470614ca2fe71e7fbaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4d3db7b5ee6efcaf940de38f32d190"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#ga0d4d3db7b5ee6efcaf940de38f32d190">sl_IfRead</a></td></tr>
<tr class="memdesc:ga0d4d3db7b5ee6efcaf940de38f32d190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read up to len bytes from an opened communication channel into a buffer starting at pBuff.  <a href="group__porting__interface.html#ga0d4d3db7b5ee6efcaf940de38f32d190">More...</a><br /></td></tr>
<tr class="separator:ga0d4d3db7b5ee6efcaf940de38f32d190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca4940235fc8e01cdad18a0908fda34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#gaaca4940235fc8e01cdad18a0908fda34">sl_IfWrite</a></td></tr>
<tr class="memdesc:gaaca4940235fc8e01cdad18a0908fda34"><td class="mdescLeft">&#160;</td><td class="mdescRight">attempts to write up to len bytes to the SPI channel  <a href="group__porting__interface.html#gaaca4940235fc8e01cdad18a0908fda34">More...</a><br /></td></tr>
<tr class="separator:gaaca4940235fc8e01cdad18a0908fda34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e17e205005322be3b619eeeeec9f069"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#ga0e17e205005322be3b619eeeeec9f069">sl_IfRegIntHdlr</a>(InterruptHdl,  pValue)&#160;&#160;&#160;SlStudio_RegisterInterruptHandler(InterruptHdl , pValue)</td></tr>
<tr class="memdesc:ga0e17e205005322be3b619eeeeec9f069"><td class="mdescLeft">&#160;</td><td class="mdescRight">register an interrupt handler routine for the host IRQ  <a href="group__porting__interface.html#ga0e17e205005322be3b619eeeeec9f069">More...</a><br /></td></tr>
<tr class="separator:ga0e17e205005322be3b619eeeeec9f069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134a6c4658baae78724989e8a36d7be0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#ga134a6c4658baae78724989e8a36d7be0">sl_IfMaskIntHdlr</a>()</td></tr>
<tr class="memdesc:ga134a6c4658baae78724989e8a36d7be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masks the Host IRQ.  <a href="group__porting__interface.html#ga134a6c4658baae78724989e8a36d7be0">More...</a><br /></td></tr>
<tr class="separator:ga134a6c4658baae78724989e8a36d7be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b2a3ae727a4e932ee45ea17fe4f701"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#gab3b2a3ae727a4e932ee45ea17fe4f701">sl_IfUnMaskIntHdlr</a>()</td></tr>
<tr class="memdesc:gab3b2a3ae727a4e932ee45ea17fe4f701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmasks the Host IRQ.  <a href="group__porting__interface.html#gab3b2a3ae727a4e932ee45ea17fe4f701">More...</a><br /></td></tr>
<tr class="separator:gab3b2a3ae727a4e932ee45ea17fe4f701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd77caa77de50bd06faf1f5b3280255c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__porting__interface.html#gacd77caa77de50bd06faf1f5b3280255c">SL_START_WRITE_STAT</a></td></tr>
<tr class="memdesc:gacd77caa77de50bd06faf1f5b3280255c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Handers for statistics debug on write.  <a href="group__porting__interface.html#gacd77caa77de50bd06faf1f5b3280255c">More...</a><br /></td></tr>
<tr class="separator:gacd77caa77de50bd06faf1f5b3280255c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae213e0dea7b2aaf58a8fe1f6f243f4c9"><td class="memItemLeft" align="right" valign="top"><a id="gae213e0dea7b2aaf58a8fe1f6f243f4c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sl_IfStartWriteSequence</b></td></tr>
<tr class="separator:gae213e0dea7b2aaf58a8fe1f6f243f4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3c61ea510c4dc9e32e3e07edbe130b"><td class="memItemLeft" align="right" valign="top"><a id="ga3d3c61ea510c4dc9e32e3e07edbe130b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sl_IfEndWriteSequence</b></td></tr>
<tr class="separator:ga3d3c61ea510c4dc9e32e3e07edbe130b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The simple link device can work with different transport interfaces (namely,SPI or UART). Texas Instruments provides single driver that can work with all these types. This section binds the physical transport interface with the SimpleLink driver. </p>
<dl class="section note"><dt>Note</dt><dd>Correct and efficient implementation of this driver is critical for the performances of the SimpleLink device on this platform.</dd></dl>
<p>PORTING ACTION:</p><ul>
<li>None </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga93d829306f92470614ca2fe71e7fbaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93d829306f92470614ca2fe71e7fbaa2">&#9670;&nbsp;</a></span>sl_IfClose <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfClose</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes an opened interface communication port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>- file descriptor of opened communication channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upon successful completion, the function shall return 0. Otherwise, -1 shall be returned</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#ga206e7c86da4e31989d54dbd8531ce505" title="Opens an interface communication port to be used for communicating with a SimpleLink device.">sl_IfOpen</a> , <a class="el" href="group__porting__interface.html#ga0d4d3db7b5ee6efcaf940de38f32d190" title="Attempts to read up to len bytes from an opened communication channel into a buffer starting at pBuff...">sl_IfRead</a> , <a class="el" href="group__porting__interface.html#gaaca4940235fc8e01cdad18a0908fda34" title="attempts to write up to len bytes to the SPI channel">sl_IfWrite</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The prototype of the function is as follow: int xxx_IfClose(Fd_t Fd);</dd>
<dd>
belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="ga93d829306f92470614ca2fe71e7fbaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93d829306f92470614ca2fe71e7fbaa2">&#9670;&nbsp;</a></span>sl_IfClose <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfClose&#160;&#160;&#160;spi_Close</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes an opened interface communication port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>- file descriptor of opened communication channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upon successful completion, the function shall return 0. Otherwise, -1 shall be returned</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#ga206e7c86da4e31989d54dbd8531ce505" title="Opens an interface communication port to be used for communicating with a SimpleLink device.">sl_IfOpen</a> , <a class="el" href="group__porting__interface.html#ga0d4d3db7b5ee6efcaf940de38f32d190" title="Attempts to read up to len bytes from an opened communication channel into a buffer starting at pBuff...">sl_IfRead</a> , <a class="el" href="group__porting__interface.html#gaaca4940235fc8e01cdad18a0908fda34" title="attempts to write up to len bytes to the SPI channel">sl_IfWrite</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The prototype of the function is as follow: int xxx_IfClose(Fd_t Fd);</dd>
<dd>
belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="ga134a6c4658baae78724989e8a36d7be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga134a6c4658baae78724989e8a36d7be0">&#9670;&nbsp;</a></span>sl_IfMaskIntHdlr <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfMaskIntHdlr</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Masks the Host IRQ. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#gab3b2a3ae727a4e932ee45ea17fe4f701" title="Unmasks the Host IRQ.">sl_IfUnMaskIntHdlr</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a id="ga134a6c4658baae78724989e8a36d7be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga134a6c4658baae78724989e8a36d7be0">&#9670;&nbsp;</a></span>sl_IfMaskIntHdlr <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfMaskIntHdlr</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Masks the Host IRQ. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#gab3b2a3ae727a4e932ee45ea17fe4f701" title="Unmasks the Host IRQ.">sl_IfUnMaskIntHdlr</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a id="ga206e7c86da4e31989d54dbd8531ce505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga206e7c86da4e31989d54dbd8531ce505">&#9670;&nbsp;</a></span>sl_IfOpen <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfOpen</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an interface communication port to be used for communicating with a SimpleLink device. </p>
<p>Given an interface name and option flags, this function opens the communication port and creates a file descriptor. This file descriptor is used afterwards to read and write data from and to this specific communication channel. The speed, clock polarity, clock phase, chip select and all other specific attributes of the channel are all should be set to hardcoded in this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ifName</td><td>- points to the interface name/path. The interface name is an optional attributes that the simple link driver receives on opening the driver (sl_Start). In systems that the spi channel is not implemented as part of the OS device drivers, this parameter could be NULL.</td></tr>
    <tr><td class="paramname">flags</td><td>- optional flags parameters for future use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upon successful completion, the function shall open the channel and return a non-negative integer representing the file descriptor. Otherwise, -1 shall be returned</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#ga93d829306f92470614ca2fe71e7fbaa2" title="Closes an opened interface communication port.">sl_IfClose</a> , <a class="el" href="group__porting__interface.html#ga0d4d3db7b5ee6efcaf940de38f32d190" title="Attempts to read up to len bytes from an opened communication channel into a buffer starting at pBuff...">sl_IfRead</a> , <a class="el" href="group__porting__interface.html#gaaca4940235fc8e01cdad18a0908fda34" title="attempts to write up to len bytes to the SPI channel">sl_IfWrite</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The prototype of the function is as follow: Fd_t xxx_IfOpen(char* pIfName , unsigned long flags);</dd>
<dd>
belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="ga206e7c86da4e31989d54dbd8531ce505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga206e7c86da4e31989d54dbd8531ce505">&#9670;&nbsp;</a></span>sl_IfOpen <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfOpen&#160;&#160;&#160;spi_Open</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an interface communication port to be used for communicating with a SimpleLink device. </p>
<p>Given an interface name and option flags, this function opens the communication port and creates a file descriptor. This file descriptor is used afterwards to read and write data from and to this specific communication channel. The speed, clock polarity, clock phase, chip select and all other specific attributes of the channel are all should be set to hardcoded in this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ifName</td><td>- points to the interface name/path. The interface name is an optional attributes that the simple link driver receives on opening the driver (sl_Start). In systems that the spi channel is not implemented as part of the OS device drivers, this parameter could be NULL.</td></tr>
    <tr><td class="paramname">flags</td><td>- optional flags parameters for future use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upon successful completion, the function shall open the channel and return a non-negative integer representing the file descriptor. Otherwise, -1 shall be returned</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#ga93d829306f92470614ca2fe71e7fbaa2" title="Closes an opened interface communication port.">sl_IfClose</a> , <a class="el" href="group__porting__interface.html#ga0d4d3db7b5ee6efcaf940de38f32d190" title="Attempts to read up to len bytes from an opened communication channel into a buffer starting at pBuff...">sl_IfRead</a> , <a class="el" href="group__porting__interface.html#gaaca4940235fc8e01cdad18a0908fda34" title="attempts to write up to len bytes to the SPI channel">sl_IfWrite</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The prototype of the function is as follow: Fd_t xxx_IfOpen(char* pIfName , unsigned long flags);</dd>
<dd>
belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="ga0d4d3db7b5ee6efcaf940de38f32d190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d4d3db7b5ee6efcaf940de38f32d190">&#9670;&nbsp;</a></span>sl_IfRead <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfRead</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to read up to len bytes from an opened communication channel into a buffer starting at pBuff. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>- file descriptor of an opened communication channel</td></tr>
    <tr><td class="paramname">pBuff</td><td>- pointer to the first location of a buffer that contains enough space for all expected data</td></tr>
    <tr><td class="paramname">len</td><td>- number of bytes to read from the communication channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upon successful completion, the function shall return the number of read bytes. Otherwise, 0 shall be returned</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#ga93d829306f92470614ca2fe71e7fbaa2" title="Closes an opened interface communication port.">sl_IfClose</a> , <a class="el" href="group__porting__interface.html#ga206e7c86da4e31989d54dbd8531ce505" title="Opens an interface communication port to be used for communicating with a SimpleLink device.">sl_IfOpen</a> , <a class="el" href="group__porting__interface.html#gaaca4940235fc8e01cdad18a0908fda34" title="attempts to write up to len bytes to the SPI channel">sl_IfWrite</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The prototype of the function is as follow: int xxx_IfRead(Fd_t Fd , char* pBuff , int Len);</dd>
<dd>
belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="ga0d4d3db7b5ee6efcaf940de38f32d190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d4d3db7b5ee6efcaf940de38f32d190">&#9670;&nbsp;</a></span>sl_IfRead <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfRead&#160;&#160;&#160;spi_Read</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to read up to len bytes from an opened communication channel into a buffer starting at pBuff. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>- file descriptor of an opened communication channel</td></tr>
    <tr><td class="paramname">pBuff</td><td>- pointer to the first location of a buffer that contains enough space for all expected data</td></tr>
    <tr><td class="paramname">len</td><td>- number of bytes to read from the communication channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upon successful completion, the function shall return the number of read bytes. Otherwise, 0 shall be returned</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#ga93d829306f92470614ca2fe71e7fbaa2" title="Closes an opened interface communication port.">sl_IfClose</a> , <a class="el" href="group__porting__interface.html#ga206e7c86da4e31989d54dbd8531ce505" title="Opens an interface communication port to be used for communicating with a SimpleLink device.">sl_IfOpen</a> , <a class="el" href="group__porting__interface.html#gaaca4940235fc8e01cdad18a0908fda34" title="attempts to write up to len bytes to the SPI channel">sl_IfWrite</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The prototype of the function is as follow: int xxx_IfRead(Fd_t Fd , char* pBuff , int Len);</dd>
<dd>
belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="ga0e17e205005322be3b619eeeeec9f069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e17e205005322be3b619eeeeec9f069">&#9670;&nbsp;</a></span>sl_IfRegIntHdlr <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfRegIntHdlr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InterruptHdl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pValue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;SlStudio_RegisterInterruptHandler(InterruptHdl , pValue)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register an interrupt handler routine for the host IRQ </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InterruptHdl</td><td>- pointer to interrupt handler routine</td></tr>
    <tr><td class="paramname">pValue</td><td>- pointer to a memory structure that is passed to the interrupt handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upon successful registration, the function shall return 0. Otherwise, -1 shall be returned</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If there is already registered interrupt handler, the function should overwrite the old handler with the new one</dd>
<dd>
If the handler is a null pointer, the function should un-register the interrupt handler, and the interrupts can be disabled.</dd>
<dd>
belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="ga0e17e205005322be3b619eeeeec9f069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e17e205005322be3b619eeeeec9f069">&#9670;&nbsp;</a></span>sl_IfRegIntHdlr <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfRegIntHdlr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InterruptHdl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pValue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;registerInterruptHandler(InterruptHdl , pValue)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register an interrupt handler routine for the host IRQ </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InterruptHdl</td><td>- pointer to interrupt handler routine</td></tr>
    <tr><td class="paramname">pValue</td><td>- pointer to a memory structure that is passed to the interrupt handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upon successful registration, the function shall return 0. Otherwise, -1 shall be returned</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If there is already registered interrupt handler, the function should overwrite the old handler with the new one</dd>
<dd>
If the handler is a null pointer, the function should un-register the interrupt handler, and the interrupts can be disabled.</dd>
<dd>
belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="gab3b2a3ae727a4e932ee45ea17fe4f701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3b2a3ae727a4e932ee45ea17fe4f701">&#9670;&nbsp;</a></span>sl_IfUnMaskIntHdlr <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfUnMaskIntHdlr</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmasks the Host IRQ. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#ga134a6c4658baae78724989e8a36d7be0" title="Masks the Host IRQ.">sl_IfMaskIntHdlr</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a id="gab3b2a3ae727a4e932ee45ea17fe4f701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3b2a3ae727a4e932ee45ea17fe4f701">&#9670;&nbsp;</a></span>sl_IfUnMaskIntHdlr <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfUnMaskIntHdlr</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmasks the Host IRQ. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#ga134a6c4658baae78724989e8a36d7be0" title="Masks the Host IRQ.">sl_IfMaskIntHdlr</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a id="gaaca4940235fc8e01cdad18a0908fda34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaca4940235fc8e01cdad18a0908fda34">&#9670;&nbsp;</a></span>sl_IfWrite <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfWrite</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>attempts to write up to len bytes to the SPI channel </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>- file descriptor of an opened communication channel</td></tr>
    <tr><td class="paramname">pBuff</td><td>- pointer to the first location of a buffer that contains the data to send over the communication channel</td></tr>
    <tr><td class="paramname">len</td><td>- number of bytes to write to the communication channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upon successful completion, the function shall return the number of sent bytes. otherwise, 0 shall be returned</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#ga93d829306f92470614ca2fe71e7fbaa2" title="Closes an opened interface communication port.">sl_IfClose</a> , <a class="el" href="group__porting__interface.html#ga206e7c86da4e31989d54dbd8531ce505" title="Opens an interface communication port to be used for communicating with a SimpleLink device.">sl_IfOpen</a> , <a class="el" href="group__porting__interface.html#ga0d4d3db7b5ee6efcaf940de38f32d190" title="Attempts to read up to len bytes from an opened communication channel into a buffer starting at pBuff...">sl_IfRead</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function could be implemented as zero copy and return only upon successful completion of writing the whole buffer, but in cases that memory allocation is not too tight, the function could copy the data to internal buffer, return back and complete the write in parallel to other activities as long as the other SPI activities would be blocked until the entire buffer write would be completed</dd></dl>
<p>The prototype of the function is as follow: int xxx_IfWrite(Fd_t Fd , char* pBuff , int Len);</p>
<dl class="section note"><dt>Note</dt><dd>belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="gaaca4940235fc8e01cdad18a0908fda34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaca4940235fc8e01cdad18a0908fda34">&#9670;&nbsp;</a></span>sl_IfWrite <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_IfWrite&#160;&#160;&#160;spi_Write</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>attempts to write up to len bytes to the SPI channel </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>- file descriptor of an opened communication channel</td></tr>
    <tr><td class="paramname">pBuff</td><td>- pointer to the first location of a buffer that contains the data to send over the communication channel</td></tr>
    <tr><td class="paramname">len</td><td>- number of bytes to write to the communication channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upon successful completion, the function shall return the number of sent bytes. otherwise, 0 shall be returned</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__porting__interface.html#ga93d829306f92470614ca2fe71e7fbaa2" title="Closes an opened interface communication port.">sl_IfClose</a> , <a class="el" href="group__porting__interface.html#ga206e7c86da4e31989d54dbd8531ce505" title="Opens an interface communication port to be used for communicating with a SimpleLink device.">sl_IfOpen</a> , <a class="el" href="group__porting__interface.html#ga0d4d3db7b5ee6efcaf940de38f32d190" title="Attempts to read up to len bytes from an opened communication channel into a buffer starting at pBuff...">sl_IfRead</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function could be implemented as zero copy and return only upon successful completion of writing the whole buffer, but in cases that memory allocation is not too tight, the function could copy the data to internal buffer, return back and complete the write in parallel to other activities as long as the other SPI activities would be blocked until the entire buffer write would be completed</dd></dl>
<p>The prototype of the function is as follow: int xxx_IfWrite(Fd_t Fd , char* pBuff , int Len);</p>
<dl class="section note"><dt>Note</dt><dd>belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="gacd77caa77de50bd06faf1f5b3280255c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd77caa77de50bd06faf1f5b3280255c">&#9670;&nbsp;</a></span>SL_START_WRITE_STAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SL_START_WRITE_STAT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write Handers for statistics debug on write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface</td><td>handler - pointer to interrupt handler routine</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>An optional hooks for monitoring before and after write info</dd>
<dd>
belongs to porting_sec</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
